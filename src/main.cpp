/*
 * Copyright 2011, 2012 Gary R. Van Sickle (grvs@users.sourceforge.net).
 *
 * This file is part of CoFlo.
 *
 * CoFlo is free software: you can redistribute it and/or modify it under the
 * terms of version 3 of the GNU General Public License as published by the Free
 * Software Foundation.
 *
 * CoFlo is distributed in the hope that it will be useful, but WITHOUT ANY
 * WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A
 * PARTICULAR PURPOSE.  See the GNU General Public License for more details.
 * 
 * You should have received a copy of the GNU General Public License along with
 * CoFlo.  If not, see <http://www.gnu.org/licenses/>.
 */

#include <string>
#include <vector>
#include <iostream>
#include <fstream>

#include <boost/version.hpp>
#include <boost/config.hpp>
#include <boost/program_options.hpp>
#include <boost/exception/all.hpp>

// Include the config.h file generated by configure.
#include "../config.h"

#include "debug_utils/debug_utils.hpp"

// The command line/config file parser.
#include "RuntimeConfiguration.h"

#include "Function.h"
#include "Program.h"
#include "libexttools/ToolCompiler.h"
#include "libexttools/ToolDot.h"
#include "controlflowgraph/analysis/Analyzer.h"

/**
 * CoFlo entry point.
 * 
 * @param argc Number of command line arguments.
 * @param argv Pointers to the command line strings.
 * @return 0 on success, non-zero on failure.
 */
int main(int argc, char* argv[])
{
	// Wrap the whole program in a try/catch block.
	try
	{
		Program *the_program;
		Analyzer *the_analyzer;

		// Subprograms we'll need.
		std::string the_filter;
		std::string the_gcc;
		std::string the_dot;

		// The HTML report output directory.
		std::string report_output_directory;

		// The output filename.
		std::string output_filename;

		// The CFG output format.
		std::string cfg_fmt;
	
		// Debug settings.
		bool debug_parse = false;
		bool debug_link = false;
		bool debug_cfg = false;

		// Control flow graph option flags.
		// Whether to limit display to only function calls, or to everything CoFlo
		// recognizes.
		bool cfg_verbose = false;
		// Enable or disable outputting vertex IDs.
		bool cfg_vertex_ids = false;
	
		// Declare a variables_map to take the command line options we're passed.
		boost::program_options::variables_map vm;
	
		// Catch any exceptions thrown by the command-line parser.
		// Usually this will be an unrecognized parameter.
		try
		{
			RuntimeConfiguration runtime_configuration(argc, argv);

			if(runtime_configuration.wasHelpOrVersion())
			{
				return 0;
			}

			vm = runtime_configuration.GetVarMapCopy();

			// Get the vars we need.
			the_gcc = vm[CLP_USE_GCC].as<std::string>();
			the_dot = vm[CLP_USE_DOT].as<std::string>();
			output_filename = vm[CLP_CFG_OUTPUT_FILENAME].as<std::string>();
			cfg_verbose = vm[CLP_CFG_VERBOSE].as<bool>();
			cfg_vertex_ids = vm[CLP_CFG_VERTEX_IDS].as<bool>();
			debug_parse = vm[CLP_DEBUG_PARSE].as<bool>();
			debug_link = vm[CLP_DEBUG_LINK].as<bool>();
			debug_cfg = vm[CLP_DEBUG_CFG].as<bool>();
			cfg_fmt = vm[CLP_CFG_FMT].as<std::string>();

			// Were any source files given on the command line?
			if(vm.count(CLP_INPUT_FILE)>0)
			{
				// Yes, try to parse them and generate a CFG.
				try
				{
					// Enable/disable debug output.
					/// @todo Add debug_link control.
					dlog_parse_gimple.enable(debug_parse);
					dlog_function.enable(debug_parse);
					dlog_cfg.enable(debug_cfg);

					the_program = new Program();
					the_analyzer = new Analyzer();

					const std::vector<std::string> *defines, *includes;
					if(vm.count(CLP_DEFINE)>0)
					{
						defines = &(vm[CLP_DEFINE].as< std::vector<std::string> >());
					}
					else
					{
						defines = new std::vector<std::string>();
					}
					if(vm.count(CLP_INCLUDE_DIR)>0)
					{
						includes = &(vm[CLP_INCLUDE_DIR].as< std::vector<std::string> >());
					}
					else
					{
						includes = new std::vector<std::string>();
					}

					the_program->SetTheFilter(the_filter);
					ToolCompiler *tool_compiler = new ToolCompiler(the_gcc);
					std::cout << "Using GCC version: " << tool_compiler->GetVersion() << std::endl;

					// Check if this version of GCC is going to work.
					VersionNumber compiler_version = tool_compiler->GetVersion();
					if(compiler_version < VersionNumber("4.5.0"))
					{
						std::cerr << "ERROR: CoFlo requires a GCC version of at least 4.5.0, reported version was " << compiler_version << std::endl;
						return 1;
					}
					std::cerr << "Setting GCC..." << std::endl;
					the_program->SetTheGcc(tool_compiler);
					std::cerr << "Adding source files..." << std::endl;
					the_program->AddSourceFiles(vm[CLP_INPUT_FILE].as< std::vector<std::string> >());

					// Parse the program.
					T_ID_TO_FUNCTION_CALL_UNRESOLVED_MAP unresolved_function_calls;
					std::cerr << "Parsing program..." << std::endl;
					if(!the_program->Parse(
						*defines,
						*includes,
						&unresolved_function_calls,
						debug_parse))
					{
						// Parse failed.
						return 1;
					}

					// Print any function calls that we couldn't link.
					the_program->PrintUnresolvedFunctionCalls(&unresolved_function_calls);
				}
				catch( boost::exception & e )
				{
					std::cerr << "ERROR: EXCEPTION CAUGHT: " << boost::diagnostic_information(e) << std::endl;
					return 1;
				}
				catch(...)
				{
					std::cerr << "ERROR: Unknown exception: " << std::endl;
					return 1;
				}
			}

			// Now we've parsed the source code and generated the CFG internally.
			// What does the caller want us to do with this info?

			if(vm.count(CLP_PRINT_FUNCTION_CFG))
			{
				// User wants a control flow graph.

				// First see if the specified function exists.
				Function *fp = the_program->LookupFunction(vm[CLP_PRINT_FUNCTION_CFG].as<std::string>());
				if(fp == NULL)
				{
					std::cerr << "ERROR: Unable to find function with identifier \"" << vm[CLP_PRINT_FUNCTION_CFG].as<std::string>() << "\"";
					return 1;
				}

				// Check if they want it as text, a Graphviz dot input file, or a png generated by dot.
				if(cfg_fmt == "img")
				{
					if(output_filename.empty())
					{
						std::cerr << "ERROR: Must specify output filename with img format." << std::endl;
					}
					ToolDot *tool_dot = new ToolDot(the_dot);
					fp->PrintControlFlowGraphBitmap(tool_dot, output_filename);
				}
				else if (cfg_fmt == "dot")
				{
					if(output_filename.empty())
					{
						std::cerr << "ERROR: Must specify output filename with dot format." << std::endl;
					}
					fp->PrintControlFlowGraphDot(cfg_verbose, cfg_vertex_ids, output_filename);
				}
				else
				{
					if(!the_program->PrintFunctionCFG(vm[CLP_PRINT_FUNCTION_CFG].as<std::string>(), cfg_verbose, cfg_vertex_ids))
					{
						// Something went wrong.
						return 1;
					}
				}
			}

			if(vm.count(CLP_CONSTRAINT) > 0)
			{
				// User wants to run some analysis.

				the_analyzer->AttachToProgram(the_program);

				// Add the given constraints to the analysis.
				the_analyzer->AddConstraints(vm[CLP_CONSTRAINT].as< std::vector<std::string> >());

				// Perform the analysis.
				the_analyzer->Analyze();
			}

			// Does the user want a report generated?
			if(vm.count(CLP_OUTPUT_DIR) > 0)
			{
				// User wants HTML output of the CFGs of all the functions.
				report_output_directory = vm[CLP_OUTPUT_DIR].as<std::string>();
				ToolDot *tool_dot = new ToolDot(the_dot);
				the_program->SetTheDot(tool_dot);
				std::cout << "Using Dot version: " << tool_dot->GetVersion() << std::endl;
				the_program->Print(report_output_directory);
			}

		}
		catch(std::exception &e)
		{
			// Something went wrong while trying to parse the command line.
			// Print an error message and exit.
			std::cerr << "ERROR: Couldn't parse command line: " << e.what() << std::endl;
			return 1;
		}
		catch(...)
		{
			std::cerr << "ERROR: Unknown exception" << std::endl;
			return 1;
		}

		// Normal return, no errors.
		return 0;
	}
	catch( boost::exception & e )
	{
		std::cerr << "ERROR: EXCEPTION CAUGHT: " << boost::diagnostic_information(e) << std::endl;
		return 1;
	}
	catch(...)
	{
		std::cerr << "ERROR: Unknown exception: " << std::endl;
		return 1;
	}
}
