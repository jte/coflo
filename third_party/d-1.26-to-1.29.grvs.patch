diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/ansic.g dparser-gitpull-export/ansic.g
--- d/ansic.g	1969-12-31 18:00:00.000000000 -0600
+++ dparser-gitpull-export/ansic.g	2012-12-02 20:05:32.000000000 -0600
@@ -0,0 +1,202 @@
+{ 
+#include <stdio.h>
+#include <string.h>
+
+char *reserved_words[] = { "auto", "break", "case", "char", "const", 
+  "continue", "default", "do", "double", "else", "enum", "extern", "float", 
+  "for", "goto", "if", "int", "long", "register", "return", "short", "signed",
+  "sizeof", "static", "struct", "typedef", "union", "unsigned", "void", 
+  "volatile", "while", NULL};
+
+static int is_one_of(char *s, char *e, char **list) {
+  while (*list) { 
+    if (strlen(*list) == e-s && !strncmp(s, *list, e-s)) return 1; 
+    list++; 
+  }
+  return 0;
+}
+}
+
+program: statements ;
+
+statements: statement*;
+statements_expr: statements expression?;
+statement: function_definition 
+	   | declaration ';' 
+	   | expression ';' 
+	   | '{' statements_expr '}';
+
+function_definition 
+  : declaration_specifiers declarator '{' statements_expr '}' ;
+
+declaration : declaration_specifiers init_declarator_list? ;
+
+init_declarator_list :	init_declarator (',' init_declarator)* ;
+init_declarator : declarator ('=' initializer)? ;
+
+declaration_specifiers 
+  : (storage_class_specifier | type_specifier | type_qualifier)+ ;
+
+storage_class_specifier: 'auto' | 'register' | 'static' | 'extern' | 'typedef';
+
+type_specifier: 'void' | 'char' | 'short' | 'int' | 'long' | 'float' 
+  | 'double' | 'signed' | 'unsigned' | struct_or_union_specifier 
+  | enum_specifier | typeID;
+
+type_qualifier: 'const' | 'volatile';
+
+typeID: identifier [
+/*
+  D_Sym *s = find_sym(${scope}, $n0.start, $n0.end);
+  if (!s) ${reject};
+  if (!s->user.is_typename) ${reject}; 
+*/
+];
+
+struct_or_union_specifier: ('struct' | 'union') 
+  ( identifier | identifier? '{' struct_declaration+ '}') ;
+
+struct_declaration : specifier_qualifier_list struct_declarator_list ';' ;
+
+specifier_qualifier_list : (type_specifier | type_qualifier)+ ;
+
+struct_declarator_list : struct_declarator (',' struct_declarator)* ;
+
+struct_declarator : declarator | declarator? ':' constant;
+
+enum_specifier : 'enum' 
+  ( identifier ('{' enumerator_list '}')? 
+  | '{' enumerator_list '}') ;
+enumerator_list : enumerator (',' enumerator)* ;
+enumerator : identifier ('=' expression)?;
+
+declarator : '*' type_qualifier* declarator | direct_declarator ;
+
+direct_declarator : identifier declarator_suffix*
+                  | '(' declarator ')' declarator_suffix* ;
+
+declarator_suffix : '[' expression? ']' | '(' parameter_list? ')';
+
+parameter_list : parameter_declaration_list ( "," "..." )? ;
+
+parameter_declaration 
+  : declaration_specifiers (declarator? | abstract_declarator) ;
+
+initializer : expr | '{' initializer (',' initializer)* '}' ;
+
+type_name : specifier_qualifier_list abstract_declarator ;
+
+abstract_declarator 
+  : '*' type_qualifier* abstract_declarator 
+  | '(' abstract_declarator ')' abstract_declarator_suffix+
+  | ('[' expression? ']')+
+  | ;
+
+abstract_declarator_suffix
+  : '[' expression? ']'
+  | '('  parameter_declaration_list? ')' ;
+
+parameter_declaration_list 
+  : parameter_declaration ( ',' parameter_declaration )* ;
+
+expression
+  : expr
+  | expr ',' expr $left 6700
+  /* labels */
+  | identifier ':' expression $right 6600
+  | 'case' expression ':' expression $right 6500
+  | 'default' ':' expression $right 6500
+  /* conditionals */
+  | 'if' '(' statements_expr ')' expression $right 6000
+  | 'if' '(' statements_expr ')' statement 'else' expression $right 6100
+  | 'switch' '(' statements_expr ')' expression $right 6200
+  /* loops */
+  | 'while' '(' statements_expr ')' expression $right 6300
+  | 'do' statement 'while' expression $right 6400
+  | 'for' '(' expression (';' expression (';' expression)?)? ')' 
+          expression $right 6500
+  /* jump */
+  | 'goto' expression? 
+  | 'continue' expression? 
+  | 'break' expression? 
+  | 'return' expression? 
+  | expression juxiposition expression
+  ;
+
+juxiposition: $binary_op_left 5000;
+
+expr 
+  : identifier 
+  | constant
+  | strings
+  | '(' statements_expr')'
+  | '[' statements_expr ']'
+  | '{' statements_expr '}'
+  | expr '?' expression ':' expr $right 8600
+  /* post operators */
+  | expr '--' $left 9900 
+  | expr '++' $left 9900
+  | expr '(' statements_expr ')' $left 9900
+  | expr '[' statements_expr ']' $left 9900
+  | expr '{' statements_expr '}' $left 9900
+  /* pre operators */
+  | 'sizeof' expression $right 9900
+  | '-' expr $right 9800 
+  | '+' expr $right 9800
+  | '~' expr $right 9800
+  | '!' expr $right 9800
+  | '*' expr $right 9800 
+  | '&' expr $right 9800
+  | '--' expr $right 9800 
+  | '++' expr $right 9800
+  | '(' type_name ')' expr $right 9800
+  /* binary operators */
+  | expr '->' expr $left 9900
+  | expr '.' expr $left 9900
+  | expr '*' expr $left 9600 
+  | expr '/' expr $left 9600
+  | expr '%' expr $left 9600
+  | expr '+' expr $left 9500 
+  | expr '-' expr $left 9500
+  | expr '<<' expr $left 9400 
+  | expr '>>' expr $left 9400
+  | expr '<' expr $left 9300 
+  | expr '<=' expr $left 9300
+  | expr '>' expr $left 9300 
+  | expr '>=' expr $left 9300
+  | expr '==' expr $left 9200 
+  | expr '!=' expr $left 9200
+  | expr '&' expr $left 9100
+  | expr '^' expr $left 9000
+  | expr '|' expr $left 8900
+  | expr '&&' expr $left 8800 
+  | expr '||' expr $left 8700
+  | expr '=' expr $left 8500
+  | expr '*=' expr $left 8500 
+  | expr '/=' expr $left 8500
+  | expr '%=' expr $left 8500
+  | expr '+=' expr $left 8500 
+  | expr '-=' expr $left 8500
+  | expr '<<=' expr $left 8500 
+  | expr '>>=' expr $left 8500
+  | expr '&=' expr $left 8500 
+  | expr '|=' expr $left 8500
+  | expr '^=' expr $left 8500
+  | expr application expr
+  ;
+
+application: $binary_op_left 7000;
+
+strings: string | strings string $left 10000;
+constant : decimalint | hexint | octalint | character | float1 | float2;
+character: "'[^']*'";
+string: "\"[^\"]*\"";
+decimalint: "[1-9][0-9]*[uUlL]?" $term -1;
+hexint: "(0x|0X)[0-9a-fA-F]+[uUlL]?" $term -2;
+octalint: "0[0-7]*[uUlL]?" $term -3;
+float1: "([0-9]+.[0-9]*|[0-9]*.[0-9]+)([eE][\-\+]?[0-9]+)?[fFlL]?" $term -4;
+float2: "[0-9]+[eE][\-\+]?[0-9]+[fFlL]?" $term -5;
+identifier: "[a-zA-Z_][a-zA-Z0-9_]*" $term -6 [
+  if (is_one_of($n0.start, $n0.end, reserved_words))
+    ${reject};
+];
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/baseline dparser-gitpull-export/baseline
--- d/baseline	2012-12-02 18:56:11.463932100 -0600
+++ dparser-gitpull-export/baseline	2012-12-02 20:05:32.000000000 -0600
@@ -1,4 +1,4 @@
-#!/usr/local/bin/tcsh
+#!/bin/tcsh
 
 setenv MAKE gmake
 parser_tests
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/buildall dparser-gitpull-export/buildall
--- d/buildall	1969-12-31 18:00:00.000000000 -0600
+++ dparser-gitpull-export/buildall	2012-12-02 20:05:32.000000000 -0600
@@ -0,0 +1,29 @@
+#!/bin/csh
+# CYGWIN
+rm -f tests/*.h tests/*.o tests/*.c tests/Makefile tests/*core tests/*.out tests/make_dparser tests/sample_parser tests/libdparse.a tests/grammar.g tests/sample.g
+gmake tar
+scp ../d*.tar.gz Owner@island: 
+ssh -l Owner island "tar xzf d*-src.tar.gz"
+ssh -l Owner island "rm d*.tar.gz"
+ssh -l Owner island "(cd d;make clean;rm -f .depend;make depend;make;make test;make bintar)"
+scp "Owner@island:d*-CYGWIN-bin.tar.gz" . 
+ssh -l Owner island "rm d*-CYGWIN-bin.tar.gz"
+# FreeBSD
+gmake clean
+rm -f .depend
+gmake depend
+gmake
+gmake test
+gmake bintar
+mv ../d*-FreeBSD-bin.tar.gz .
+# Linux
+scp ../d*.tar.gz b:
+ssh b "tar xzf d*-src.tar.gz"
+ssh b "rm d*.tar.gz"
+ssh b "(cd d;make clean;rm -f .depend;gmake depend;make;make test;make bintar)"
+scp "b:d*-Linux-bin.tar.gz" . 
+ssh b "rm d*-Linux-bin.tar.gz"
+# put 'em in place
+cp *-bin.tar.gz /home/jplevyak/public_html/Compilers
+cp ../d*.tar.gz /home/jplevyak/public_html/Compilers
+cp README /home/jplevyak/public_html/Compilers
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/CHANGES dparser-gitpull-export/CHANGES
--- d/CHANGES	2012-12-02 18:56:11.541932200 -0600
+++ dparser-gitpull-export/CHANGES	2012-12-02 20:05:32.000000000 -0600
@@ -1,3 +1,10 @@
+1.29    Fixed bug with handling of priorities and associativity (thanx Sjoerd Cranen)
+
+1.28    Fixed bug with actions containing commments containing '
+        Python 2.6+ support, thanx to jonas@lophus.org
+
+1.27    Fixed error with input ending on C++ style comment (thanx voiz)
+
 1.26    Unicode fix thanx to agsags
         Fixed some compilation warnings
 
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/faq.html dparser-gitpull-export/faq.html
--- d/faq.html	2012-12-02 18:56:11.557532300 -0600
+++ dparser-gitpull-export/faq.html	2012-12-02 20:05:32.000000000 -0600
@@ -12,7 +12,7 @@
 <div style="text-align: left;"><big><br>
 <br>
 <span style="font-weight: bold;"></span></big><span
- style="font-weight: bold;"><span style="font-weight: bold;">1. How do
+ style="font-weight: bold;"><span style="font-weight: bold;">1a. How do
 I access the subnodes for expressions like "S: A*;" ?<br>
 <span style="font-weight: bold;"><span style="font-weight: bold;"><span
  style="font-weight: bold;"><br>
@@ -25,6 +25,17 @@
 d_get_child(&amp;$n0, x).<br>
 <br>
 See the example: tests/g27.test.g<br>
+<br>
+<span style="font-weight: bold;"></span></big><span
+ style="font-weight: bold;"><span style="font-weight: bold;">1b. How do
+I access the subnodes for expressions like "S: (A)*;" ?<br>
+<span style="font-weight: bold;"><span style="font-weight: bold;"><span
+ style="font-weight: bold;"><br>
+</span></span></span></span></span>In this case, you get the number of 
+children (<span style="font-weight: bold;">A</span>'s) by calling
+d_get_number_of_children(&amp;$n0) and individual children by calling
+d_get_child(d_get_child(&amp;$n0, x), 0).<br>
+<br>
 <span style="font-weight: bold;"><br>
 <span style="font-weight: bold;">2. Why doesn't '$n0.end_skip' include
 the trailing whitespace when $n0 is a string/regex?<br>
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/index.html dparser-gitpull-export/index.html
--- d/index.html	2012-12-02 18:56:11.557532300 -0600
+++ dparser-gitpull-export/index.html	2012-12-02 20:05:32.000000000 -0600
@@ -95,7 +95,7 @@
 </span><span style="font-weight: bold;">Download<br>
 <br>
 &nbsp;&nbsp;&nbsp;&nbsp; <a
- href="http://prdownloads.sourceforge.net/dparser/d-1.26-src.tar.gz">Source
+ href="http://prdownloads.sourceforge.net/dparser/d-1.29-src.tar.gz">Source
 (tar.gz)</a><br>
 <br>
 </span><a href="http://sourceforge.net/projects/dparser/"><span
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/Makefile dparser-gitpull-export/Makefile
--- d/Makefile	2012-12-02 18:56:11.557532300 -0600
+++ dparser-gitpull-export/Makefile	2012-12-02 20:05:32.000000000 -0600
@@ -1,16 +1,17 @@
 # Makefile for D_Parser
 
 #D_DEBUG=1
-D_OPTIMIZE=1
+#D_OPTIMIZE=1
 #D_PROFILE=1
 #D_USE_GC=1
 #D_LEAK_DETECT=1
 D_USE_FREELISTS=1
 
 MAJOR=1
-MINOR=26
+MINOR=29
 RELEASE=$(MAJOR).$(MINOR)
 
+EXEEXT = .exe
 CC = gcc
 
 ifndef PREFIX
@@ -64,13 +65,13 @@
 CFLAGS += -DUSE_FREELISTS
 endif
 
-D_BUILD_VERSION = $(shell svnversion .)
-ifeq ($(D_BUILD_VERSION),exported)
+#D_BUILD_VERSION = $(shell svnversion .)
+#ifeq ($(D_BUILD_VERSION),exported)
   D_BUILD_VERSION = $(shell git show-ref 2> /dev/null | head -1 | cut -d ' ' -f 1)
   ifeq ($(D_BUILD_VERSION),)
     D_BUILD_VERSION = $(shell cat D_BUILD_VERSION)
   endif
-endif
+#endif
 CFLAGS += -DD_MAJOR_VERSION=$(MAJOR) -DD_MINOR_VERSION=$(MINOR) -DD_BUILD_VERSION=\"$(D_BUILD_VERSION)\"
 
 CFLAGS += -Wall
@@ -127,22 +128,22 @@
 TEST_PARSER_SRCS = test_parser.c
 TEST_PARSER_OBJS = $(TEST_PARSER_SRCS:%.c=%.o)
 
-MAKE_DPARSER = ./make_dparser
+MAKE_DPARSER = ./make_dparser$(EXEEXT)
 
-EXECUTABLES = make_dparser
+EXECUTABLES = make_dparser$(EXEEXT)
 LIBRARIES = $(LIBMKDPARSE) $(LIBDPARSE)
 INSTALL_LIBRARIES = $(LIBDPARSE)
 INCLUDES = dparse.h dparse_tables.h dsymtab.h dparse_tree.h
 MANPAGES = make_dparser.1
 
-EXECS = $(EXECUTABLES) sample_parser test_parser
-ifeq ($(OS_TYPE),CYGWIN)
-EXEC_FILES = $(EXECS:%=%.exe)
-EXECUTABLE_FILES = $(EXECUTABLES:%=%.exe)
-else
+EXECS = $(EXECUTABLES) sample_parser$(EXEEXT) test_parser$(EXEEXT)
+#ifeq ($(OS_TYPE),CYGWIN)
+#EXEC_FILES = $(EXECS:%=%.exe)
+#EXECUTABLE_FILES = $(EXECUTABLES:%=%.exe)
+#else
 EXEC_FILES = $(EXECS)
 EXECUTABLE_FILES = $(EXECUTABLES)
-endif
+#endif
 
 ALL_SRCS = $(MAKE_PARSER_SRCS) $(BASE_SAMPLE_PARSER_SRCS) $(LIB_SRCS) $(MK_LIB_SRCS)
 
@@ -170,7 +171,7 @@
 	rm $(INSTALL_LIBRARIES:%=$(PREFIX)/lib/%)
 	rm $(MANPAGES:%=$(PREFIX)/man/man1/%)
 
-make_dparser: $(MAKE_PARSER_OBJS) $(LIBRARIES)
+make_dparser$(EXEEXT): $(MAKE_PARSER_OBJS) $(LIBRARIES)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ version.c $(LIBS) 
 
 $(LIBDPARSE): $(LIB_OBJS)
@@ -181,20 +182,20 @@
 	ar cruv $@ $^
 	ranlib $@
 
-%.d_parser.c: % make_dparser
+%.d_parser.c: % make_dparser$(EXEEXT)
 	$(MAKE_DPARSER) $<
 
-sample_parser: $(SAMPLE_PARSER_OBJS) $(INSTALL_LIBRARIES)
+sample_parser$(EXEEXT): $(SAMPLE_PARSER_OBJS) $(INSTALL_LIBRARIES)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ version.c $(LIBS)
 
-test_parser: $(TEST_PARSER_OBJS) $(LIBRARIES)
+test_parser$(EXEEXT): $(TEST_PARSER_OBJS) $(LIBRARIES)
 	$(CC) $(CFLAGS) $(LDFLAGS) -o $@ $^ version.c $(LIBS)
 
-myexample: make_dparser
+myexample: make_dparser$(EXEEXT)
 	$(MAKE_DPARSER) my.g
 	cc -I/usr/local/include my.c my.g.d_parser.c -L/usr/local/lib -ldparse
 
-gram: make_dparser
+gram: make_dparser$(EXEEXT)
 	$(MAKE_DPARSER) -i dparser_gram grammar.g
 	mv grammar.g.d_parser.c grammar.g.c
 	rm -f grammar.g.o
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/parse.c dparser-gitpull-export/parse.c
--- d/parse.c	2012-12-02 18:56:11.557532300 -0600
+++ dparser-gitpull-export/parse.c	2012-12-02 20:05:32.000000000 -0600
@@ -5,13 +5,18 @@
 #include "d.h"
 
 /* tunables */
-#define DEFAULT_COMMIT_ACTIONS_INTERVAL		100
-#define PNODE_HASH_INITIAL_SIZE_INDEX		10
-#define SNODE_HASH_INITIAL_SIZE_INDEX		8
-#define ERROR_RECOVERY_QUEUE_SIZE		10000
+#define DEFAULT_COMMIT_ACTIONS_INTERVAL         100
+#define PNODE_HASH_INITIAL_SIZE_INDEX           10
+#define SNODE_HASH_INITIAL_SIZE_INDEX           8
+#define ERROR_RECOVERY_QUEUE_SIZE               10000
 
 #define LATEST(_p, _pn) do { \
-  while ((_pn)->latest != (_pn)->latest->latest) {PNode *t = (_pn)->latest->latest; ref_pn(t); unref_pn((_p),(_pn)->latest); (_pn)->latest = t;}\
+  while ((_pn)->latest != (_pn)->latest->latest) { \
+    PNode *t = (_pn)->latest->latest; \
+    ref_pn(t); \
+    unref_pn((_p), (_pn)->latest); \
+    (_pn)->latest = t; \
+  }\
   (_pn) = (_pn)->latest; \
 } while (0)
 
@@ -43,15 +48,15 @@
   if (!p->error_recovery) {
     if (p->children.n) {
       if (p->children.n > 1)
-	printf("(");
+        printf("(");
       for (i = 0; i < p->children.n; i++)
-	print_paren(pp, p->children.v[i]);
+        print_paren(pp, p->children.v[i]);
       if (p->children.n > 1)
-	printf(")");
+        printf(")");
     } else if (p->parse_node.start_loc.s != p->parse_node.end_skip) {
       printf(" ");
       for (c = p->parse_node.start_loc.s; c < p->parse_node.end_skip; c++)
-	printf("%c", *c);
+        printf("%c", *c);
       printf(" ");
     }
   }
@@ -67,12 +72,12 @@
     if (p->children.n) {
       printf("(");
       for (i = 0; i < p->children.n; i++)
-	xprint_paren(pp, p->children.v[i]);
+        xprint_paren(pp, p->children.v[i]);
       printf(")");
     } else if (p->parse_node.start_loc.s != p->parse_node.end_skip) {
       printf(" ");
       for (c = p->parse_node.start_loc.s; c < p->parse_node.end_skip; c++)
-	printf("%c", *c);
+        printf("%c", *c);
       printf(" ");
     }
     if (p->ambiguities) {
@@ -141,9 +146,9 @@
   if (ph->v)
     for (sn = ph->v[h % ph->m]; sn; sn = sn->bucket_next)
       if (sn->state - p->t->state == state &&
-	  sn->initial_scope == sc &&
-	  sn->initial_globals == g)
-	return sn;
+          sn->initial_scope == sc &&
+          sn->initial_globals == g)
+        return sn;
   return NULL;
 }
 
@@ -161,9 +166,9 @@
     ph->v = (SNode**)MALLOC(ph->m * sizeof(*ph->v));
     memset(ph->v, 0, ph->m * sizeof(*ph->v));
     for (i = 0; i < m; i++)
-      while ((t = v[i])) { 
-	v[i] = v[i]->bucket_next;
-	insert_SNode_internal(p, t);
+      while ((t = v[i])) {
+        v[i] = v[i]->bucket_next;
+        insert_SNode_internal(p, t);
       }
     FREE(v);
   }
@@ -176,7 +181,7 @@
 static void
 insert_SNode(Parser *p, SNode *sn) {
   insert_SNode_internal(p, sn);
-  ref_sn(sn); 
+  ref_sn(sn);
   sn->all_next = p->snode_hash.all;
   p->snode_hash.all = sn;
 }
@@ -309,13 +314,13 @@
   if (ph->v)
     for (pn = ph->v[h % ph->m]; pn; pn = pn->bucket_next)
       if (pn->hash == h &&
-	  pn->parse_node.symbol == symbol &&
-	  pn->parse_node.start_loc.s == start &&
-	  pn->parse_node.end_skip == end_skip &&
-	  pn->initial_scope == sc &&
-	  pn->initial_globals == g) {
-	LATEST(p, pn);
-	return pn;
+          pn->parse_node.symbol == symbol &&
+          pn->parse_node.start_loc.s == start &&
+          pn->parse_node.end_skip == end_skip &&
+          pn->initial_scope == sc &&
+          pn->initial_globals == g) {
+        LATEST(p, pn);
+        return pn;
       }
   return NULL;
 }
@@ -323,8 +328,8 @@
 void
 insert_PNode_internal(Parser *p, PNode *pn) {
   PNodeHash *ph = &p->pnode_hash;
-  uint h = PNODE_HASH(pn->parse_node.start_loc.s, pn->parse_node.end_skip, 
-		      pn->parse_node.symbol, pn->initial_scope, pn->initial_globals), i;
+  uint h = PNODE_HASH(pn->parse_node.start_loc.s, pn->parse_node.end_skip,
+                      pn->parse_node.symbol, pn->initial_scope, pn->initial_globals), i;
   PNode *t;
 
   if (ph->n + 1 > ph->m) {
@@ -335,9 +340,9 @@
     ph->v = (PNode**)MALLOC(ph->m * sizeof(*ph->v));
     memset(ph->v, 0, ph->m * sizeof(*ph->v));
     for (i = 0; i < m; i++)
-      while ((t = v[i])) { 
-	v[i] = v[i]->bucket_next;
-	insert_PNode_internal(p, t);
+      while ((t = v[i])) {
+        v[i] = v[i]->bucket_next;
+        insert_PNode_internal(p, t);
       }
     FREE(v);
   }
@@ -379,13 +384,13 @@
     for (i = 0; i < pn->children.n; i++) {
       while (pn->children.v[i] != pn->children.v[i]->latest) {
         tpn = pn->children.v[i]->latest;
-	ref_pn(tpn);
-	unref_pn(p, pn->children.v[i]);
-	pn->children.v[i] = tpn;
+        ref_pn(tpn);
+        unref_pn(p, pn->children.v[i]);
+        pn->children.v[i] = tpn;
       }
     }
-    h = PNODE_HASH(pn->parse_node.start_loc.s, pn->parse_node.end_skip, 
-		   pn->parse_node.symbol, pn->initial_scope, pn->initial_globals);
+    h = PNODE_HASH(pn->parse_node.start_loc.s, pn->parse_node.end_skip,
+                   pn->parse_node.symbol, pn->initial_scope, pn->initial_globals);
     lpn = &p->pnode_hash.v[h % p->pnode_hash.m];
     tpn = pn; pn = pn->all_next;
     while (*lpn != tpn) lpn = &(*lpn)->bucket_next;
@@ -396,23 +401,23 @@
   p->pnode_hash.all = NULL;
 }
 
-static void 
+static void
 alloc_parser_working_data(Parser *p) {
   p->pnode_hash.i = PNODE_HASH_INITIAL_SIZE_INDEX;
   p->pnode_hash.m = d_prime2[p->pnode_hash.i];
-  p->pnode_hash.v = 
+  p->pnode_hash.v =
     (PNode**)MALLOC(p->pnode_hash.m * sizeof(*p->pnode_hash.v));
   memset(p->pnode_hash.v, 0, p->pnode_hash.m * sizeof(*p->pnode_hash.v));
   p->snode_hash.i = SNODE_HASH_INITIAL_SIZE_INDEX;
   p->snode_hash.m = d_prime2[p->snode_hash.i];
-  p->snode_hash.v = 
+  p->snode_hash.v =
     (SNode**)MALLOC(p->snode_hash.m * sizeof(*p->snode_hash.v));
   memset(p->snode_hash.v, 0, p->snode_hash.m * sizeof(*p->snode_hash.v));
   p->nshift_results = 0;
   p->ncode_shifts = 0;
 }
 
-static void 
+static void
 free_parser_working_data(Parser *p) {
   int i;
 
@@ -487,11 +492,11 @@
     dd = znode_depth(x->znode);
     if ((sn->loc.s == x->snode->loc.s && d >= dd)) {
       if (d == dd)
-	while (x) {
-	  if (sn == x->snode && z == x->znode && reduction == x->reduction)
-	    return NULL;
-	  x = x->next;
-	}
+        while (x) {
+          if (sn == x->snode && z == x->znode && reduction == x->reduction)
+            return NULL;
+          x = x->next;
+        }
       break;
     }
   }
@@ -547,7 +552,7 @@
 reduce_actions(Parser *p, PNode *pn, D_Reduction *r) {
   int i, height = 0;
   PNode *c;
-  
+
   for (i = 0; i < pn->children.n; i++) {
     c = pn->children.v[i];
     if (c->op_assoc) {
@@ -572,16 +577,16 @@
 }
 
 #define x 666 /* impossible */
-static int child_table[4][3][6] = { 
-{ 
+static int child_table[4][3][6] = {
+{
 /* binary parent, child on left */
   /* priority of child vs parent, or = with child|parent associativity
-     > < =LL =LR =RL =RR 
+     > < =LL =LR =RL =RR
    */
   { 1, 0, 1, 1, 0, 0}, /* binary child */
   { 1, 1, 1, 1, x, x}, /* left unary child */
   { 1, 0, x, x, 1, 1}  /* right unary child */
-}, 
+},
 { /* binary parent, child on right */
   { 1, 0, 0, 0, 1, 1}, /* binary child */
   { 1, 0, 1, 1, x, x}, /* left unary child */
@@ -589,13 +594,13 @@
 },
 { /* left unary parent */
   { 1, 0, 0, x, 0, x}, /* binary child */
-  { 1, 0, 1, x, x, x}, /* left unary child */
-  { 1, 1, x, x, 1, x}  /* right unary child */
+  { 1, 1, 1, x, x, x}, /* left unary child */
+  { 1, 0, x, x, 1, x}  /* right unary child */
 },
 { /* right unary parent */
   { 1, 0, x, 0, x, 0}, /* binary child */
-  { 1, 1, x, 1, x, x}, /* left unary child */
-  { 1, 0, x, x, x, 1}  /* right unary child */
+  { 1, 0, x, 1, x, x}, /* left unary child */
+  { 1, 1, x, x, x, 1}  /* right unary child */
 }
 };
 #undef x
@@ -603,17 +608,17 @@
 /* returns 1 if legal for child reduction and illegal for child shift */
 static int
 check_child(int ppri, AssocKind passoc, int cpri, AssocKind cassoc,
-	    int left, int right) 
+            int left, int right)
 {
-  int p = IS_BINARY_NARY_ASSOC(passoc) ? (right ? 1 : 0) : 
+  int p = IS_BINARY_NARY_ASSOC(passoc) ? (right ? 1 : 0) :
           (passoc == ASSOC_UNARY_LEFT ? 2 : 3);
-  int c = IS_BINARY_NARY_ASSOC(cassoc) ? 0 : 
+  int c = IS_BINARY_NARY_ASSOC(cassoc) ? 0 :
           (cassoc == ASSOC_UNARY_LEFT ? 1 : 2);
-  int r = 
+  int r =
     cpri > ppri ? 0 : (
       cpri < ppri ? 1 : ( 2 + (
-	(IS_RIGHT_ASSOC(cassoc) ? 2 : 0) +
-	(IS_RIGHT_ASSOC(passoc) ? 1 : 0))));
+        (IS_RIGHT_ASSOC(cassoc) ? 2 : 0) +
+        (IS_RIGHT_ASSOC(passoc) ? 1 : 0))));
   return child_table[p][c][r];
 }
 
@@ -624,29 +629,29 @@
     if (IS_UNARY_BINARY_ASSOC(pn1->op_assoc)) { /* second token is operator */
       /* check expression pn0 (child of pn1) */
       if (pn0->assoc) {
-	if (!check_child(pn1->op_priority, pn1->op_assoc, 
-			 pn0->priority, pn0->assoc, 0, 1))
-	return -1;
+        if (!check_child(pn1->op_priority, pn1->op_assoc,
+                         pn0->priority, pn0->assoc, 0, 1))
+        return -1;
       }
     }
   } else { /* pn0 is an operator */
     if (pn1->op_assoc) {
       /* check pn0 (child of operator pn1) */
       if (!check_child(pn1->op_priority, pn1->op_assoc,
-		       pn0->op_priority, pn0->op_assoc, 0, 1))
-	return -1;
+                       pn0->op_priority, pn0->op_assoc, 0, 1))
+        return -1;
     } else if (pn2) {
       /* check pn0 (child of operator pn2) */
       if (pn2->op_assoc &&
-	  !check_child(pn2->op_priority, pn2->op_assoc,
-		       pn0->op_priority, pn0->op_assoc, 0, 1)) 
-	return -1;
+          !check_child(pn2->op_priority, pn2->op_assoc,
+                       pn0->op_priority, pn0->op_assoc, 0, 1))
+        return -1;
     }
     /* check expression pn1 (child of pn0)  */
     if (pn1->assoc) {
       if (!check_child(pn0->op_priority, pn0->op_assoc,
-		       pn1->priority, pn1->assoc, 1, 0)) 
-	return -1;
+                       pn1->priority, pn1->assoc, 1, 0))
+        return -1;
     }
   }
   return 0;
@@ -663,7 +668,7 @@
   if (path->n < i + 1)
     return 0;
   pn0 = path->v[i]->pn;
-  if (!pn0->op_assoc) {	/* deal with top expression directly */
+  if (!pn0->op_assoc) { /* deal with top expression directly */
     i = 1;
     if (path->n < i + 1)
       return 0;
@@ -671,9 +676,9 @@
     if (!pn1->op_assoc)
       return 0;
     if (pn0->assoc) {
-      if (!check_child(pn1->op_priority, pn1->op_assoc, 
-		       pn0->priority, pn0->assoc, 0, 1))
-	return -1;
+      if (!check_child(pn1->op_priority, pn1->op_assoc,
+                       pn0->priority, pn0->assoc, 0, 1))
+        return -1;
     }
     pn0 = pn1;
   }
@@ -684,28 +689,28 @@
     else { /* one level from the stack beyond the path */
       z = path->v[i + 1];
       for (k = 0; k < z->sns.n; k++)
-	for (j = 0; j < z->sns.v[k]->zns.n; j++) {
-	  one = 1;
-	  zz = z->sns.v[k]->zns.v[j];
-	  if (zz && !check_assoc_priority(pn0, pn1, zz->pn))
-	    return 0;
-	}
+        for (j = 0; j < z->sns.v[k]->zns.n; j++) {
+          one = 1;
+          zz = z->sns.v[k]->zns.v[j];
+          if (zz && !check_assoc_priority(pn0, pn1, zz->pn))
+            return 0;
+        }
       if (!one)
-	return check_assoc_priority(pn0, pn1, NULL);
+        return check_assoc_priority(pn0, pn1, NULL);
     }
   } else { /* two levels from the stack beyond the path */
     z = path->v[i];
     for (k = 0; k < z->sns.n; k++)
       for (j = 0; j < z->sns.v[k]->zns.n; j++) {
-	zz = z->sns.v[k]->zns.v[j];
-	if (zz)
-	  for (kk = 0; kk < zz->sns.n; kk++)
-	    for (jj = 0; jj < zz->sns.v[kk]->zns.n; jj++) {
-	      one = 1;
-	      zzz = zz->sns.v[kk]->zns.v[jj];
-	      if (zzz && !check_assoc_priority(pn0, zz->pn, zzz->pn))
-		return 0;
-	    }
+        zz = z->sns.v[k]->zns.v[j];
+        if (zz)
+          for (kk = 0; kk < zz->sns.n; kk++)
+            for (jj = 0; jj < zz->sns.v[kk]->zns.n; jj++) {
+              one = 1;
+              zzz = zz->sns.v[kk]->zns.v[jj];
+              if (zzz && !check_assoc_priority(pn0, zz->pn, zzz->pn))
+                return 0;
+            }
       }
     return 0;
   }
@@ -713,8 +718,8 @@
 }
 
 /* avoid cases without operator priorities */
-#define check_path_priorities(_p) ((_p)->n > 1 			&& \
-   ((_p)->v[0]->pn->op_assoc || (_p)->v[1]->pn->op_assoc)	&& \
+#define check_path_priorities(_p) ((_p)->n > 1                  && \
+   ((_p)->v[0]->pn->op_assoc || (_p)->v[1]->pn->op_assoc)       && \
    check_path_priorities_internal(_p))
 
 static int
@@ -731,23 +736,18 @@
   return 0;
 }
 
-static void 
-intsort(int *xp, int n) {
-  int again = 1, i, t;
-  while (again) {
-    again = 0;
-    for (i = 0; i < n - 1; i++) {
-      if (xp[i] > xp[i+1]) {
-	t = xp[i];
-	xp[i] = xp[i + 1];
-	xp[i + 1] = t;
-	again = 1;
-      }
-    }
+static void
+intreverse(int *xp, int n) {
+  int *a = xp, *b = xp + n -1;
+  while (a < b) {
+    int t = *a;
+    *a = *b;
+    *b = t;
+    a++; b--;
   }
 }
 
-/* sort by deepest, then by address */
+/* sort by deepest, then by location */
 static void
 priority_insert(StackPNode *psx, PNode *x) {
   PNode *t, **start, **cur;
@@ -758,7 +758,8 @@
   for (;cur > start + 1;cur--) {
     if (cur[-1]->height > cur[-2]->height)
       continue;
-    if (cur[-1]->height == cur[-2]->height && cur[-1] > cur[-2])
+    if (cur[-1]->height == cur[-2]->height &&
+        cur[-1]->parse_node.start_loc.s > cur[-2]->parse_node.start_loc.s)
       continue;
     t = cur[-1];
     cur[-1] = cur[-2];
@@ -790,9 +791,9 @@
     stack_push(isx, x->priority);
     for (i = 0; i < x->children.n; i++)
       if (x->children.v[i]->assoc)
-	get_exp_one(p, x->children.v[i], psx, isx);
+        get_exp_one(p, x->children.v[i], psx, isx);
   }
-} 
+}
 
 static void
 get_exp_one_down(Parser *p, PNode *x, StackPNode *psx, StackInt *isx) {
@@ -803,13 +804,13 @@
   for (i = 0; i < x->children.n; i++)
     if (x->children.v[i]->assoc)
       get_exp_one(p, x->children.v[i], psx, isx);
-} 
+}
 
-/* get the set of priorities for unshared nodes, 
+/* get the set of priorities for unshared nodes,
    eliminating shared subtrees via priority queues */
 static void
 get_unshared_priorities(Parser *p, StackPNode *psx, StackPNode *psy,
-			StackInt *isx, StackInt *isy) 
+                        StackInt *isx, StackInt *isy)
 {
   StackPNode *psr;
   PNode *t;
@@ -831,7 +832,7 @@
     else if (stack_head(psx) < stack_head(psy))
       psr = psy;
     else {
-      (void)stack_pop(psx); 
+      (void)stack_pop(psx);
       (void)stack_pop(psy);
       continue;
     }
@@ -852,7 +853,7 @@
 }
 
 /* compare the priorities of operators in two trees
-   while eliminating common subtrees for efficiency. 
+   while eliminating common subtrees for efficiency.
 */
 static int
 cmp_priorities(Parser *p, PNode *x, PNode *y) {
@@ -863,10 +864,10 @@
   get_exp_one(p, x, &psx, &isx);
   get_exp_one(p, y, &psy, &isy);
   get_unshared_priorities(p, &psx, &psy, &isx, &isy);
-  intsort(isx.start, stack_depth(&isx));
-  intsort(isy.start, stack_depth(&isy));
-  int r = compare_priorities(isx.start, stack_depth(&isx), 
-		     isy.start, stack_depth(&isy));
+  intreverse(isx.start, stack_depth(&isx));
+  intreverse(isy.start, stack_depth(&isy));
+  int r = compare_priorities(isx.start, stack_depth(&isx),
+                     isy.start, stack_depth(&isy));
   stack_free(&psx); stack_free(&psy); stack_free(&isx); stack_free(&isy);
   return r;
 }
@@ -887,7 +888,7 @@
 get_unshared_pnodes(Parser *p, PNode *x, PNode *y, VecPNode *pvx, VecPNode *pvy) {
   int i;
   VecPNode vx, vy;
-  vec_clear(&vx); vec_clear(&vy); 
+  vec_clear(&vx); vec_clear(&vy);
   LATEST(p, x); LATEST(p, y);
   get_all(p, x, &vx);
   get_all(p, y, &vy);
@@ -927,7 +928,7 @@
 static int
 cmp_greediness(Parser *p, PNode *x, PNode *y) {
   VecPNode pvx, pvy;
-  vec_clear(&pvx); vec_clear(&pvy); 
+  vec_clear(&pvx); vec_clear(&pvy);
   get_unshared_pnodes(p, x, y, &pvx, &pvy);
   /* set_to_vec(&pvx); set_to_vec(&pvy); */
   qsort(pvx.v, pvx.n, sizeof(PNode *), greedycmp);
@@ -968,7 +969,7 @@
 
 int
 resolve_amb_greedy(D_Parser *dp, int n, D_ParseNode **v) {
-  int i, result, selected_node= 0;
+  int i, result, selected_node = 0;
 
   for(i=1; i<n; i++) {
      result = cmp_greediness((Parser *)dp, D_ParseNode_to_PNode(v[i]),D_ParseNode_to_PNode( v[selected_node]) );
@@ -979,19 +980,12 @@
   return selected_node;
 }
 
+/* return -1 for x, 1 for y and 0 if they are ambiguous */
 static int
 cmp_pnodes(Parser *p, PNode *x, PNode *y) {
   int r = 0;
   if (x->assoc && y->assoc) {
-    /* simple case */
-    if (!IS_NARY_ASSOC(x->assoc) && !IS_NARY_ASSOC(y->assoc)) {
-      if (x->priority > y->priority)
-	return -1;
-      if (x->priority < y->priority)
-	return 1;
-    } 
-    r = cmp_priorities(p, x, y);
-    if (r)
+    if ((r = cmp_priorities(p, x, y)))
       return r;
   }
   if (!p->user.dont_use_greediness_for_disambiguation)
@@ -1008,7 +1002,7 @@
 
 static PNode *
 make_PNode(Parser *p, uint hash, int symbol, d_loc_t *start_loc, char *e, PNode *pn,
-	   D_Reduction *r, VecZNode *path, D_Shift *sh, D_Scope *scope)
+           D_Reduction *r, VecZNode *path, D_Shift *sh, D_Scope *scope)
 {
   int i, l = sizeof(PNode) - sizeof(d_voidp) + p->user.sizeof_user_parse_node;
   PNode *new_pn = p->free_pnodes;
@@ -1028,7 +1022,7 @@
   new_pn->parse_node.symbol = symbol;
   new_pn->parse_node.start_loc = *start_loc;
   new_pn->ws_before = start_loc->ws;
-  if (!r || !path) /* end of last parse node of path for non-epsilon reductions */ 
+  if (!r || !path) /* end of last parse node of path for non-epsilon reductions */
     new_pn->parse_node.end = e;
   else
     new_pn->parse_node.end = pn->parse_node.end;
@@ -1051,21 +1045,21 @@
       dummy.action_index = sh->action_index;
       new_pn->reduction = &dummy;
       if (sh->speculative_code(
-	new_pn, (void**)&new_pn->children.v[0], new_pn->children.n,
-	(intptr_t)&((PNode*)(NULL))->parse_node, (D_Parser*)p)) 
+        new_pn, (void**)&new_pn->children.v[0], new_pn->children.n,
+        (intptr_t)&((PNode*)(NULL))->parse_node, (D_Parser*)p))
       {
-	free_PNode(p, new_pn);
-	return NULL;
+        free_PNode(p, new_pn);
+        return NULL;
       }
       new_pn->reduction = NULL;
     }
   } else if (r) {
     if (path)
       for (i = path->n - 1; i >= 0; i--) {
-	PNode *latest = path->v[i]->pn;
-	LATEST(p, latest);
+        PNode *latest = path->v[i]->pn;
+        LATEST(p, latest);
    ref_pn(latest);
-	vec_add(&new_pn->children, latest);
+        vec_add(&new_pn->children, latest);
       }
     if (reduce_actions(p, new_pn, r)) {
       free_PNode(p, new_pn);
@@ -1074,14 +1068,14 @@
     if (path && path->n > 1) {
       int n = path->n;
       for (i = 0; i < n; i += n-1) {
-	PNode *child = new_pn->children.v[i];
-	if (child->assoc && 
-	    !check_child(new_pn->priority, new_pn->assoc,
-			 child->priority, child->assoc, i == 0, i == n - 1)) 
-	{
-	  free_PNode(p, new_pn);
-	  return NULL;
-	}
+        PNode *child = new_pn->children.v[i];
+        if (child->assoc &&
+            !check_child(new_pn->priority, new_pn->assoc,
+                         child->priority, child->assoc, i == 0, i == n - 1))
+        {
+          free_PNode(p, new_pn);
+          return NULL;
+        }
       }
     }
   }
@@ -1103,7 +1097,7 @@
       LATEST(p, x);
       LATEST(p, y);
       if (x != y)
-	return 0;
+        return 0;
     }
     return 1;
   }
@@ -1113,13 +1107,13 @@
 /* find/create PNode */
 static PNode *
 add_PNode(Parser *p, int symbol, d_loc_t *start_loc, char *e, PNode *pn,
-	  D_Reduction *r, VecZNode *path, D_Shift *sh) 
+          D_Reduction *r, VecZNode *path, D_Shift *sh)
 {
   D_Scope *scope = equiv_D_Scope(pn->parse_node.scope);
   uint hash;
-  PNode *old_pn = find_PNode(p, start_loc->s, e, symbol, scope, pn->parse_node.globals, &hash), 
+  PNode *old_pn = find_PNode(p, start_loc->s, e, symbol, scope, pn->parse_node.globals, &hash),
     *new_pn;
-  if (old_pn) { 
+  if (old_pn) {
     PNode *amb = 0;
     if (PNode_equal(p, old_pn, r, path, sh))
       return old_pn;
@@ -1152,7 +1146,7 @@
       old_pn->latest = new_pn;
       old_pn = new_pn;
       break;
-    case 1: 
+    case 1:
       free_PNode(p, new_pn);
       break;
   }
@@ -1182,13 +1176,13 @@
   if (n <= INTEGRAL_VEC_SIZE) {
     for (i = 0; i < n; i++)
       if (v->v[i]->pn == pn)
-	return v->v[i];
+        return v->v[i];
     return NULL;
   }
   h = ((uintptr_t)pn) % n;
-  for (i = h, j = 0; 
-       i < v->n && j < SET_MAX_SEQUENTIAL; 
-       i = ((i + 1) % n), j++) 
+  for (i = h, j = 0;
+       i < v->n && j < SET_MAX_SEQUENTIAL;
+       i = ((i + 1) % n), j++)
   {
     if (!v->v[i])
       return NULL;
@@ -1205,13 +1199,13 @@
   int i, j, n = v->n;
   if (n) {
     uint h = ((uintptr_t)z->pn) % n;
-    for (i = h, j = 0; 
-	 i < v->n && j < SET_MAX_SEQUENTIAL; 
-	 i = ((i + 1) % n), j++) 
+    for (i = h, j = 0;
+         i < v->n && j < SET_MAX_SEQUENTIAL;
+         i = ((i + 1) % n), j++)
     {
       if (!v->v[i]) {
-	v->v[i] = z;
-	return;
+        v->v[i] = z;
+        return;
       }
     }
   }
@@ -1251,16 +1245,16 @@
   set_add_znode_hash(v, z);
 }
 
-#define GOTO_STATE(_p, _pn, _ps) 				\
-  ((_p)->t->goto_table[(_pn)->parse_node.symbol - 		\
-		      (_ps)->state->goto_table_offset] - 1)
+#define GOTO_STATE(_p, _pn, _ps)                                \
+  ((_p)->t->goto_table[(_pn)->parse_node.symbol -               \
+                      (_ps)->state->goto_table_offset] - 1)
 static SNode *
 goto_PNode(Parser *p, d_loc_t *loc, PNode *pn, SNode *ps) {
   SNode *new_ps, *pre_ps;
   ZNode *z = NULL;
   D_State *state;
   int i, j, k, state_index;
-  
+
   if (!IS_BIT_SET(ps->state->goto_valid, pn->parse_node.symbol))
     return NULL;
   state_index = GOTO_STATE(p, pn, ps);
@@ -1270,11 +1264,11 @@
     unref_pn(p, new_ps->last_pn);
   ref_pn(pn);
   new_ps->last_pn = pn;
-  
-  DBG(printf("goto %d (%s) -> %d %p\n", 
-	     (int)(ps->state - p->t->state), 
-	     p->t->symbols[pn->parse_node.symbol].name,
-	     state_index, new_ps));
+
+  DBG(printf("goto %d (%s) -> %d %p\n",
+             (int)(ps->state - p->t->state),
+             p->t->symbols[pn->parse_node.symbol].name,
+             state_index, new_ps));
   if (ps != new_ps && new_ps->depth < ps->depth + 1)
     new_ps->depth = ps->depth + 1;
   /* find/create ZNode */
@@ -1283,21 +1277,21 @@
     set_add_znode(&new_ps->zns, (z = new_ZNode(p, pn)));
     for (j = 0; j < new_ps->state->reductions.n; j++)
       if (new_ps->state->reductions.v[j]->nelements)
-	add_Reduction(p, z, new_ps, new_ps->state->reductions.v[j]);
+        add_Reduction(p, z, new_ps, new_ps->state->reductions.v[j]);
     if (!pn->shift)
       for (j = 0; j < new_ps->state->right_epsilon_hints.n; j++) {
-	D_RightEpsilonHint *h = &new_ps->state->right_epsilon_hints.v[j];
-	pre_ps = find_SNode(p, h->preceeding_state, new_ps->initial_scope, new_ps->initial_globals);
-	if (!pre_ps) continue;
-	for (k = 0; k < pre_ps->zns.n; k++)
-	  if (pre_ps->zns.v[k]) {
-	    Reduction *r =
-	      add_Reduction(p, pre_ps->zns.v[k], pre_ps, h->reduction);
-	    if (r) {
-	      r->new_snode = new_ps;
-	      r->new_depth = h->depth;
-	    }
-	  }
+        D_RightEpsilonHint *h = &new_ps->state->right_epsilon_hints.v[j];
+        pre_ps = find_SNode(p, h->preceeding_state, new_ps->initial_scope, new_ps->initial_globals);
+        if (!pre_ps) continue;
+        for (k = 0; k < pre_ps->zns.n; k++)
+          if (pre_ps->zns.v[k]) {
+            Reduction *r =
+              add_Reduction(p, pre_ps->zns.v[k], pre_ps, h->reduction);
+            if (r) {
+              r->new_snode = new_ps;
+              r->new_depth = h->depth;
+            }
+          }
       }
   }
   for (i = 0; i < z->sns.n; i++)
@@ -1350,8 +1344,8 @@
     state = s->snode->state;
     if (state->scanner_code) {
       if (p->ncode_shifts < ncode + 1) {
-	p->ncode_shifts = ncode + 2;
-	p->code_shifts = REALLOC(p->code_shifts, p->ncode_shifts * sizeof(D_Shift));
+        p->ncode_shifts = ncode + 2;
+        p->code_shifts = REALLOC(p->code_shifts, p->ncode_shifts * sizeof(D_Shift));
       }
       p->code_shifts[ncode].shift_kind = D_SCAN_ALL;
       p->code_shifts[ncode].term_priority = 0;
@@ -1360,18 +1354,18 @@
       p->code_shifts[ncode].speculative_code = 0;
       p->shift_results[nshifts].loc = loc;
       if ((state->scanner_code(
-	&p->shift_results[nshifts].loc, 
-	&p->code_shifts[ncode].symbol, &p->code_shifts[ncode].term_priority, 
-	&p->code_shifts[ncode].op_assoc, &p->code_shifts[ncode].op_priority))) 
+        &p->shift_results[nshifts].loc,
+        &p->code_shifts[ncode].symbol, &p->code_shifts[ncode].term_priority,
+        &p->code_shifts[ncode].op_assoc, &p->code_shifts[ncode].op_priority)))
       {
-	p->shift_results[nshifts].snode = s->snode;
-	p->shift_results[nshifts++].shift = &p->code_shifts[ncode++];
+        p->shift_results[nshifts].snode = s->snode;
+        p->shift_results[nshifts++].shift = &p->code_shifts[ncode++];
       }
     }
     if (state->scanner_table) {
       int n = scan_buffer(&loc, state, &p->shift_results[nshifts]);
       for (i = 0; i < n; i++)
-	p->shift_results[nshifts + i].snode = s->snode;
+        p->shift_results[nshifts + i].snode = s->snode;
       nshifts += n;
     }
   }
@@ -1384,27 +1378,27 @@
       SNode *sn = r->snode;
       r->shift = 0;
       for (j = i + 1; j < nshifts; j++) {
-	if (p->shift_results[j].shift && 
-	    sn == p->shift_results[j].snode &&
-	    symbol == p->shift_results[j].shift->symbol) {
-	  r->shift = p->shift_results[j].shift;
-	  p->shift_results[j].shift = 0;
-	}
+        if (p->shift_results[j].shift &&
+            sn == p->shift_results[j].snode &&
+            symbol == p->shift_results[j].shift->symbol) {
+          r->shift = p->shift_results[j].shift;
+          p->shift_results[j].shift = 0;
+        }
       }
     }
     if (r->shift && r->shift->term_priority) {
       /* potentially n^2 but typically small */
       for (j = 0; j < nshifts; j++) {
-	if (!p->shift_results[j].shift)
-	  continue;
-	if (r->loc.s == p->shift_results[j].loc.s && j != i) {
-	  if (r->shift->term_priority < p->shift_results[j].shift->term_priority) {
-	    r->shift = 0;
-	    break;
-	  }
-	  if (r->shift->term_priority > p->shift_results[j].shift->term_priority)
-	    p->shift_results[j].shift = 0;
-	}
+        if (!p->shift_results[j].shift)
+          continue;
+        if (r->loc.s == p->shift_results[j].loc.s && j != i) {
+          if (r->shift->term_priority < p->shift_results[j].shift->term_priority) {
+            r->shift = 0;
+            break;
+          }
+          if (r->shift->term_priority > p->shift_results[j].shift->term_priority)
+            p->shift_results[j].shift = 0;
+        }
       }
     }
   }
@@ -1413,20 +1407,20 @@
     if (!r->shift)
       continue;
     p->shifts++;
-    DBG(printf("shift %d %p %d (%s)\n", 
-	       (int)(r->snode->state - p->t->state), r->snode, r->shift->symbol,
-	       p->t->symbols[r->shift->symbol].name));
+    DBG(printf("shift %d %p %d (%s)\n",
+               (int)(r->snode->state - p->t->state), r->snode, r->shift->symbol,
+               p->t->symbols[r->shift->symbol].name));
     new_pn = add_PNode(p, r->shift->symbol, &r->snode->loc, r->loc.s,
-		       r->snode->last_pn, NULL, NULL, r->shift);
+                       r->snode->last_pn, NULL, NULL, r->shift);
     if (new_pn) {
       if (!skip_loc.s || skip_loc.s != r->loc.s || skip_fn != new_pn->parse_node.white_space) {
-	skip_loc = r->loc;
-	skip_fn = new_pn->parse_node.white_space;
-	new_pn->parse_node.white_space(
-	  (D_Parser*)p, &skip_loc, (void**)&new_pn->parse_node.globals);
-	skip_loc.ws = r->loc.s;
-	new_pn->ws_before = loc.ws;
-	new_pn->ws_after = skip_loc.s;
+        skip_loc = r->loc;
+        skip_fn = new_pn->parse_node.white_space;
+        new_pn->parse_node.white_space(
+          (D_Parser*)p, &skip_loc, (void**)&new_pn->parse_node.globals);
+        skip_loc.ws = r->loc.s;
+        new_pn->ws_before = loc.ws;
+        new_pn->ws_after = skip_loc.s;
       }
       goto_PNode(p, &skip_loc, new_pn, r->snode);
     }
@@ -1459,8 +1453,8 @@
 }
 
 static void
-build_paths_internal(ZNode *z, VecVecZNode *paths, int parent, 
-		     int n, int n_to_go) 
+build_paths_internal(ZNode *z, VecVecZNode *paths, int parent,
+                     int n, int n_to_go)
 {
   int j, k, l;
 
@@ -1470,13 +1464,13 @@
   for (k = 0; k < z->sns.n; k++)
     for (j = 0, l = 0; j < z->sns.v[k]->zns.n; j++) {
       if (z->sns.v[k]->zns.v[j]) {
-	if (k + l) {
-	  vec_add(paths, new_VecZNode(paths, n - (n_to_go - 1), parent));
-	  parent = paths->n - 1;
-	}
-	build_paths_internal(z->sns.v[k]->zns.v[j], paths, parent, 
-			     n, n_to_go - 1);
-	l++;
+        if (k + l) {
+          vec_add(paths, new_VecZNode(paths, n - (n_to_go - 1), parent));
+          parent = paths->n - 1;
+        }
+        build_paths_internal(z->sns.v[k]->zns.v[j], paths, parent,
+                             n, n_to_go - 1);
+        l++;
       }
     }
 }
@@ -1491,7 +1485,7 @@
 
 static void
 free_paths(VecVecZNode *paths) {
-  int i;  
+  int i;
   vec_free(&path1);
   for (i = 1; i < paths->n; i++) {
     vec_free(paths->v[i]);
@@ -1511,7 +1505,7 @@
 
   if (!r->znode) { /* epsilon reduction */
     if ((pn = add_PNode(p, r->reduction->symbol, &sn->loc,
-			sn->loc.s, sn->last_pn, r->reduction, 0, 0)))
+                        sn->loc.s, sn->last_pn, r->reduction, 0, 0)))
       goto_PNode(p, &sn->loc, pn, sn);
   } else {
     DBG(printf("reduce %d %p %d\n", (int)(r->snode->state - p->t->state), sn, n));
@@ -1520,30 +1514,30 @@
     for (i = 0; i < paths.n; i++) {
       path = paths.v[i];
       if (r->new_snode) { /* prune paths by new right epsilon node */
-	for (j = 0; j < path->v[r->new_depth]->sns.n; j++)
-	  if (path->v[r->new_depth]->sns.v[j] == r->new_snode)
-	    break;
-	if (j >= path->v[r->new_depth]->sns.n)
-	  continue;
+        for (j = 0; j < path->v[r->new_depth]->sns.n; j++)
+          if (path->v[r->new_depth]->sns.v[j] == r->new_snode)
+            break;
+        if (j >= path->v[r->new_depth]->sns.n)
+          continue;
       }
       if (check_path_priorities(path))
-	continue;
+        continue;
       p->reductions++;
       last_pn = path->v[0]->pn;
       first_z = path->v[n - 1];
-      pn = add_PNode(p, r->reduction->symbol, 
-		     &first_z->pn->parse_node.start_loc, 
-		     sn->loc.s, last_pn, r->reduction, path, NULL);
+      pn = add_PNode(p, r->reduction->symbol,
+                     &first_z->pn->parse_node.start_loc,
+                     sn->loc.s, last_pn, r->reduction, path, NULL);
       if (pn)
-	for (j = 0; j < first_z->sns.n; j++)
-	  goto_PNode(p, &sn->loc, pn, first_z->sns.v[j]);
+        for (j = 0; j < first_z->sns.n; j++)
+          goto_PNode(p, &sn->loc, pn, first_z->sns.v[j]);
     }
     free_paths(&paths);
   }
   unref_sn(p, sn);
   r->next = p->free_reductions;
   p->free_reductions = r;
-} 
+}
 
 static int
 VecSNode_equal(VecSNode *vsn1, VecSNode *vsn2) {
@@ -1553,7 +1547,7 @@
   for (i = 0; i < vsn1->n; i++) {
     for (j = 0; j < vsn2->n; j++) {
       if (vsn1->v[i] == vsn2->v[j])
-	break;
+        break;
     }
     if (j >= vsn2->n)
       return 0;
@@ -1582,7 +1576,7 @@
 
 #ifdef D_DEBUG
 
-static const char *spaces = "                                                                                                  "; 
+static const char *spaces = "                                                                                                  ";
 static void
 print_stack(Parser *p, SNode *s, int indent) {
   int i,j;
@@ -1599,10 +1593,10 @@
     printf(")");
     for (j = 0; j < s->zns.v[i]->sns.n; j++) {
       if (s->zns.v[i]->sns.n > 1)
-	printf("\n%s[", &spaces[98-indent]);
+        printf("\n%s[", &spaces[98-indent]);
       print_stack(p, s->zns.v[i]->sns.v[j], indent);
       if (s->zns.v[i]->sns.n > 1)
-	printf("]");
+        printf("]");
     }
     if (s->zns.n > 1)
       printf("]");
@@ -1611,7 +1605,7 @@
 #endif
 
 /* compare two stacks with operators on top of identical substacks
-   eliminating the stack with the lower priority binary operator 
+   eliminating the stack with the lower priority binary operator
    - used to eliminate unnecessary stacks created by the
      (empty) application binary operator
 */
@@ -1620,50 +1614,50 @@
   char *pos;
   Shift *a, *b, **al, **bl;
   ZNode *az, *bz;
-  
+
   pos = p->shifts_todo->snode->loc.s;
   DBG({
     int i = 0;
-    for (al = &p->shifts_todo, a = *al; a && a->snode->loc.s == pos; 
-	 al = &a->next, a = a->next)
+    for (al = &p->shifts_todo, a = *al; a && a->snode->loc.s == pos;
+         al = &a->next, a = a->next)
   {
     if (++i < 2) printf("\n");
     print_stack(p, a->snode, 0);
-    printf("\n");    
+    printf("\n");
   }});
-  for (al = &p->shifts_todo, a = *al; a && a->snode->loc.s == pos; 
-       al = &a->next, a = a->next) 
+  for (al = &p->shifts_todo, a = *al; a && a->snode->loc.s == pos;
+       al = &a->next, a = a->next)
   {
     if (!(az = binary_op_ZNode(a->snode)))
       continue;
-    for (bl = &a->next, b = a->next; b && b->snode->loc.s == pos; 
-	 bl = &b->next, b = b->next) {
+    for (bl = &a->next, b = a->next; b && b->snode->loc.s == pos;
+         bl = &b->next, b = b->next) {
       if (!(bz = binary_op_ZNode(b->snode)))
-	continue;
+        continue;
       if (!VecSNode_equal(&az->sns, &bz->sns))
-	continue;
+        continue;
       if ((a->snode->state->reduces_to != b->snode->state - p->t->state) &&
-	  (b->snode->state->reduces_to != a->snode->state - p->t->state))
-	continue;
+          (b->snode->state->reduces_to != a->snode->state - p->t->state))
+        continue;
       if (az->pn->op_priority > bz->pn->op_priority) {
-	DBG(printf("DELETE ");
-	    print_stack(p, b->snode, 0);
-	    printf("\n"));
-	*bl = b->next;
-	unref_sn(p, b->snode);
-	FREE(b);
-	b = *bl;
-	break;
+        DBG(printf("DELETE ");
+            print_stack(p, b->snode, 0);
+            printf("\n"));
+        *bl = b->next;
+        unref_sn(p, b->snode);
+        FREE(b);
+        b = *bl;
+        break;
       }
       if (az->pn->op_priority < bz->pn->op_priority) {
-	DBG(printf("DELETE ");
-	    print_stack(p, a->snode, 0);
-	    printf("\n"));
-	*al = a->next;
-	unref_sn(p, a->snode);
-	FREE(a);
-	a = *al;
-	goto Lbreak2;
+        DBG(printf("DELETE ");
+            print_stack(p, a->snode, 0);
+            printf("\n"));
+        *al = a->next;
+        unref_sn(p, a->snode);
+        FREE(a);
+        a = *al;
+        goto Lbreak2;
       }
     }
   Lbreak2:;
@@ -1675,7 +1669,7 @@
   int i;
   PNode *amb;
 
-  for (i = 0; i < pn->children.n; i++) 
+  for (i = 0; i < pn->children.n; i++)
     unref_pn(p, pn->children.v[i]);
   vec_free(&pn->children);
   if ((amb = pn->ambiguities)) {
@@ -1705,8 +1699,8 @@
       printf("\n");
     }
   }
-  d_fail("unresolved ambiguity line %d file %s", v[0]->start_loc.line, 
-	 v[0]->start_loc.pathname);
+  d_fail("unresolved ambiguity line %d file %s", v[0]->start_loc.line,
+         v[0]->start_loc.pathname);
   return v[0];
 }
 
@@ -1736,7 +1730,7 @@
     LATEST(p, amb);
     if (!p->user.dont_merge_epsilon_trees)
       if (efa && is_epsilon_PNode(amb) && final_actionless(amb))
-	continue;
+        continue;
     for (i = 0; i < pns.n; i++)
       if (pns.v[i] == &amb->parse_node)
         found = 1;
@@ -1769,7 +1763,7 @@
     pn->children.v[ichild] = child->children.v[0];
   } else {
     for (j = 0; j < n - 1; j++) /* expand children vector */
-      vec_add(&pn->children, NULL); 
+      vec_add(&pn->children, NULL);
     for (j = pnn - 1; j >= ichild + 1; j--) /* move to new places */
       pn->children.v[j - 1 + n] = pn->children.v[j];
     for (j = 0; j < n; j++) {
@@ -1790,7 +1784,7 @@
 
 static PNode *
 commit_tree(Parser *p, PNode *pn) {
-  int i, n, fixup_ebnf = 0, fixup = 0, internal = 0;
+  int i, fixup_ebnf = 0, fixup = 0, internal = 0;
   LATEST(p, pn);
   if (pn->evaluated)
     return pn;
@@ -1801,17 +1795,16 @@
   fixup_ebnf = p->user.fixup_EBNF_productions;
   internal = is_symbol_internal_or_EBNF(p, pn);
   fixup = !p->user.dont_fixup_internal_productions && internal;
-  for (i = 0; i < pn->children.n; i++) { 
+  for (i = 0; i < pn->children.n; i++) {
     PNode *tpn = commit_tree(p, pn->children.v[i]);
     if (tpn != pn->children.v[i]){
       ref_pn(tpn);
       unref_pn(p, pn->children.v[i]);
       pn->children.v[i] = tpn;
     }
-    n = pn->children.v[i]->children.n;
-    if (fixup && 
-	(fixup_ebnf ? is_symbol_internal_or_EBNF(p, pn->children.v[i]) :
-	 is_symbol_internal(p, pn->children.v[i])))
+    if (fixup &&
+        (fixup_ebnf ? is_symbol_internal_or_EBNF(p, pn->children.v[i]) :
+         is_symbol_internal(p, pn->children.v[i])))
     {
       fixup_internal_symbol(p, pn, i);
       i -= 1;
@@ -1835,12 +1828,12 @@
 commit_stack(Parser *p, SNode *sn) {
   int res = 0;
   PNode *tpn;
-  
+
   if (sn->zns.n != 1)
     return -1;
   if (sn->zns.v[0]->sns.n > 1)
     return -2;
-  if (is_unreduced_epsilon_PNode(sn->zns.v[0]->pn)) /* wait till reduced */ 
+  if (is_unreduced_epsilon_PNode(sn->zns.v[0]->pn)) /* wait till reduced */
     return -3;
   if (sn->zns.v[0]->sns.n)
     if ((res = commit_stack(p, sn->zns.v[0]->sns.v[0])) < 0)
@@ -1864,7 +1857,7 @@
   } else
     while (*str) {
       if (!strncmp(s, str, len))
-	return str + len;
+        return str + len;
       str++;
     }
   return NULL;
@@ -1878,7 +1871,7 @@
   ZNode *z = p->snode_hash.last_all ? p->snode_hash.last_all->zns.v[0] : 0;
   while (z && z->pn->parse_node.start_loc.s == z->pn->parse_node.end)
     z = (z->sns.v && z->sns.v[0]->zns.v) ? z->sns.v[0]->zns.v[0] : 0;
-  if (z && z->pn->parse_node.start_loc.s != z->pn->parse_node.end) 
+  if (z && z->pn->parse_node.start_loc.s != z->pn->parse_node.end)
     after = dup_str(z->pn->parse_node.start_loc.s, z->pn->parse_node.end);
   if (after)
     fprintf(stderr, "%s:%d: syntax error after '%s'\n", fn, p->user.loc.line, after);
@@ -1923,27 +1916,27 @@
     sn = q[head++];
     if (sn->state->error_recovery_hints.n) {
       for (i = 0; i < sn->state->error_recovery_hints.n; i++) {
-	D_ErrorRecoveryHint *er = &sn->state->error_recovery_hints.v[i];
-	if ((ss = find_substr(s, er->string))) {
-	  if (!best_sn || ss < best_s ||
-	      (best_sn && ss == best_s && 
-	       (best_sn->depth < sn->depth ||
-		 (best_sn->depth == sn->depth &&
-		   best_er->depth < er->depth)))) 
-	  {
-	    best_sn = sn;
-	    best_s = ss;
-	    best_er = er;
-	  }
-	}
+        D_ErrorRecoveryHint *er = &sn->state->error_recovery_hints.v[i];
+        if ((ss = find_substr(s, er->string))) {
+          if (!best_sn || ss < best_s ||
+              (best_sn && ss == best_s &&
+               (best_sn->depth < sn->depth ||
+                 (best_sn->depth == sn->depth &&
+                   best_er->depth < er->depth))))
+          {
+            best_sn = sn;
+            best_s = ss;
+            best_er = er;
+          }
+        }
       }
     }
     for (i = 0; i < sn->zns.n; i++)
       if (sn->zns.v[i])
-	for (j = 0; j < sn->zns.v[i]->sns.n; j++) {
-	  if (tail < ERROR_RECOVERY_QUEUE_SIZE - 1)
-	    q[tail++] = sn->zns.v[i]->sns.v[j];
-	}
+        for (j = 0; j < sn->zns.v[i]->sns.n; j++) {
+          if (tail < ERROR_RECOVERY_QUEUE_SIZE - 1)
+            q[tail++] = sn->zns.v[i]->sns.v[j];
+        }
   }
   if (best_sn) {
     D_Reduction *rr = MALLOC(sizeof(*rr));
@@ -1959,7 +1952,11 @@
     rr->symbol = best_er->symbol;
     update_line(best_loc.s, best_s, &best_loc.line);
     best_loc.s = (char*)best_s;
-    best_pn = best_sn->zns.v[0]->pn;
+    for (i = 0; i < best_sn->zns.n; i++)
+      if (best_sn->zns.v[i]) {
+        best_pn = best_sn->zns.v[i]->pn;
+        break;
+      }
     best_pn->parse_node.white_space(
       (D_Parser*)p, &best_loc, (void**)&best_pn->parse_node.globals);
     new_pn = add_PNode(p, 0, &p->user.loc,  best_loc.s, best_pn, 0, 0, 0);
@@ -1980,12 +1977,12 @@
     reduce_one(p, r);
     for (i = 0; i < p->snode_hash.m; i++)
       for (sn = p->snode_hash.v[i]; sn; sn = sn->bucket_next)
-	for (j = 0; j < sn->zns.n; j++)
-	  if ((z = sn->zns.v[j]))
-	    if (z->pn->reduction == rr) {
-	      z->pn->evaluated = 1;
-	      z->pn->error_recovery = 1;
-	    }
+        for (j = 0; j < sn->zns.n; j++)
+          if ((z = sn->zns.v[j]))
+            if (z->pn->reduction == rr) {
+              z->pn->evaluated = 1;
+              z->pn->error_recovery = 1;
+            }
     if (p->shifts_todo || p->reductions_todo)
       res = 0;
   }
@@ -1994,7 +1991,7 @@
 }
 
 #define PASS_CODE_FOUND(_p, _pn) ((_pn)->reduction && (_pn)->reduction->npass_code > (_p)->index && \
-				  (_pn)->reduction->pass_code[(_p)->index])
+                                  (_pn)->reduction->pass_code[(_p)->index])
 
 static void
 pass_call(Parser *p, D_Pass *pp, PNode *pn) {
@@ -2024,17 +2021,17 @@
   pass_call(p, pp, pn);
 }
 
-void 
+void
 d_pass(D_Parser *ap, D_ParseNode *apn, int pass_number) {
   PNode *pn = D_ParseNode_to_PNode(apn);
   Parser *p = (Parser*)ap;
   D_Pass *pp;
-  
+
   if (pass_number >= p->t->npasses)
     d_fail("bad pass number: %d\n", pass_number);
   pp = &p->t->passes[pass_number];
   if (pp->kind & D_PASS_MANUAL)
-    pass_call(p, pp, pn);	
+    pass_call(p, pp, pn);
   else if (pp->kind & D_PASS_PRE_ORDER)
     pass_preorder(p, pp, pn);
   else if (pp->kind & D_PASS_POST_ORDER)
@@ -2072,33 +2069,33 @@
     while (p->reductions_todo) {
       pos = p->reductions_todo->snode->loc.s;
       if (p->shifts_todo && p->shifts_todo->snode->loc.s < pos)
-	break;
-      if (pos > epos) { 
-	epos = pos; 
-	free_old_nodes(p); 
+        break;
+      if (pos > epos) {
+        epos = pos;
+        free_old_nodes(p);
       }
       for (;(r = p->reductions_todo) && r->snode->loc.s == pos;) {
-	p->reductions_todo = p->reductions_todo->next;
-	reduce_one(p, r);
+        p->reductions_todo = p->reductions_todo->next;
+        reduce_one(p, r);
       }
     }
     /* done? */
     if (!p->shifts_todo) {
-      if (p->accept && 
-	  (p->accept->loc.s == p->end || p->user.partial_parses))
-	return 0;
+      if (p->accept &&
+          (p->accept->loc.s == p->end || p->user.partial_parses))
+        return 0;
       else {
-	if (error_recovery(p))
-	  return 1;
-	continue;
+        if (error_recovery(p))
+          return 1;
+        continue;
       }
     } else if (!p->user.dont_compare_stacks && p->shifts_todo->next)
       cmp_stacks(p);
     /* shift all */
     pos = p->shifts_todo->snode->loc.s;
-    if (pos > epos) { 
-      epos = pos; 
-      free_old_nodes(p); 
+    if (pos > epos) {
+      epos = pos;
+      free_old_nodes(p);
     }
     progress++;
     ready = progress > p->user.commit_actions_interval;
@@ -2136,21 +2133,21 @@
       char *save = s;
       s++;
       while (wspace(*s)) s++;
-      if (!strncmp("line", s, 4)) { 
-	if (wspace(s[4])) {
-	  s += 5;
-	  while (wspace(*s)) s++;
-	}
-      }
-      if (isdigit_(*s)) { 
-	loc->line = atoi(s) - 1;
-	while (isdigit_(*s)) s++;
-	while (wspace(*s)) s++;
-	if (*s == '"')
-	  loc->pathname = s;
+      if (!strncmp("line", s, 4)) {
+        if (wspace(s[4])) {
+          s += 5;
+          while (wspace(*s)) s++;
+        }
+      }
+      if (isdigit_(*s)) {
+        loc->line = atoi(s) - 1;
+        while (isdigit_(*s)) s++;
+        while (wspace(*s)) s++;
+        if (*s == '"')
+          loc->pathname = s;
       } else {
-	s = save;
-	goto Ldone;
+        s = save;
+        goto Ldone;
       }
     }
     while (*s && *s != '\n') s++;
@@ -2158,7 +2155,7 @@
  Lmore:
   while (wspace(*s)) s++;
   if (*s == '\n') {
-    loc->line++; 
+    loc->line++;
     scol = s + 1;
     s++;
     if (*s == '#')
@@ -2169,8 +2166,6 @@
   if (s[0] == '/') {
     if (s[1] == '/') {
       while (*s && *s != '\n') { s++; }
-      loc->line++;
-      s++;
       goto Lmore;
     }
     if (s[1] == '*') {
@@ -2179,22 +2174,22 @@
       rec++;
     LmoreComment:
       while (*s) {
-	if (s[0] == '*' && s[1] == '/') {
-	  s += 2;
-	  rec--;
-	  if (!rec)
-	    goto Lmore;
-	  goto LmoreComment;
-	}
-	if (s[0] == '/' && s[1] == '*') {
-	  s += 2;
-	  goto LnestComment;
-	}
-	if (*s == '\n') { 
-	  loc->line++; 
-	  scol = s + 1; 
-	}
-	s++;
+        if (s[0] == '*' && s[1] == '/') {
+          s += 2;
+          rec--;
+          if (!rec)
+            goto Lmore;
+          goto LmoreComment;
+        }
+        if (s[0] == '/' && s[1] == '*') {
+          s += 2;
+          goto LnestComment;
+        }
+        if (*s == '\n') {
+          loc->line++;
+          scol = s + 1;
+        }
+        s++;
       }
     }
   }
@@ -2253,13 +2248,13 @@
 }
 
 static void
-copy_user_configurables(Parser *pp, Parser *p) { 
+copy_user_configurables(Parser *pp, Parser *p) {
   memcpy(((char*)&pp->user.start_state) + sizeof(pp->user.start_state),
          ((char*)&p->user.start_state) + sizeof(p->user.start_state),
          ((char*)&pp->user.syntax_errors - (char*)&pp->user.start_state));
 }
 
-Parser * 
+Parser *
 new_subparser(Parser *p) {
   Parser * pp = (Parser *)new_D_Parser(p->t, p->user.sizeof_user_parse_node);
   copy_user_configurables(pp, p);
@@ -2284,8 +2279,8 @@
 free_whitespace_parser(Parser *p) {
   if (p->whitespace_parser) {
     free_D_Parser((D_Parser*)p->whitespace_parser);
-    p->whitespace_parser = 0; 
-  } 
+    p->whitespace_parser = 0;
+  }
 }
 
 static PNode *
@@ -2324,7 +2319,7 @@
   SNode *sn;
   PNode *pn;
   D_ParseNode *res = NULL;
-  
+
   p->states = p->scans = p->shifts = p->reductions = p->compares = 0;
   p->start = buf;
   p->end = buf + buf_len;
@@ -2343,22 +2338,22 @@
   if (!r) {
     sn = p->accept;
     if (sn->zns.n != 1)
-      pn = handle_top_level_ambiguities(p, sn); 
+      pn = handle_top_level_ambiguities(p, sn);
     else
       pn = sn->zns.v[0]->pn;
     pn = commit_tree(p, pn);
     if (d_verbose_level) {
       printf(
-	"%d states %d scans %d shifts %d reductions "
-	"%d compares %d ambiguities\n", 
-	p->states, p->scans, p->shifts, p->reductions, 
-	p->compares, p->ambiguities);
+        "%d states %d scans %d shifts %d reductions "
+        "%d compares %d ambiguities\n",
+        p->states, p->scans, p->shifts, p->reductions,
+        p->compares, p->ambiguities);
       if (p->user.save_parse_tree) {
-	if (d_verbose_level > 1)
-	  xprint_paren(p, pn);
-	else
-	  print_paren(p, pn);
-	printf("\n");
+        if (d_verbose_level > 1)
+          xprint_paren(p, pn);
+        else
+          print_paren(p, pn);
+        printf("\n");
       }
     }
     if (p->user.save_parse_tree) {
@@ -2374,4 +2369,3 @@
   free_whitespace_parser(p);
   return res;
 }
-
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/parser_tests dparser-gitpull-export/parser_tests
--- d/parser_tests	2012-12-02 18:56:11.557532300 -0600
+++ dparser-gitpull-export/parser_tests	2012-12-02 20:05:32.000000000 -0600
@@ -4,28 +4,32 @@
 #setenv VALGRIND 'valgrind -q '
 setenv VALGRIND ' '
 
+set EXEEXT = .exe
+
+echo "Copying to tests";
 cp BUILD_VERSION Makefile *.c *.h grammar.g tests
+echo "Copied.";
 cd tests
-$MAKE -s make_dparser
+$MAKE -s make_dparser$EXEEXT
 $MAKE gram
-$MAKE -s make_dparser
+$MAKE -s make_dparser$EXEEXT
 set failed = 0
 foreach g (*.test.g)
-  rm -f sample_parser
+  rm -f sample_parser$EXEEXT
   if (-e $g.flags) then
     set flags = `cat $g.flags`
   else
     set flags = 
   endif
-  $VALGRIND ./make_dparser $flags $g
-  $MAKE -s sample_parser SAMPLE_GRAMMAR=$g:t
+  $VALGRIND ./make_dparser$EXEEXT $flags $g
+  $MAKE -s sample_parser$EXEEXT SAMPLE_GRAMMAR=$g:t
   foreach t ( $g.[0-9] $g.[0-9][0-9] )
     if (-e $t.flags) then
       set flags = `cat $t.flags`
     else
       set flags = 
     endif
-    $VALGRIND ./sample_parser $flags -v $t >&! $t.out
+    $VALGRIND ./sample_parser$EXEEXT $flags -v $t >&! $t.out
     diff $t.out $t.check
     if ($?) then
       echo $t "******** FAILED ********"
@@ -41,5 +45,5 @@
 else
   echo "********" $failed "test(s) FAILED *********"
 endif
-rm -f sample_parser BUILD_VERSION Makefile *.c *.h *.o make_dparser libdparse.a grammar.g
+rm -f sample_parser$EXEEXT BUILD_VERSION Makefile *.c *.h *.o make_dparser$EXEEXT libdparse.a grammar.g
 cd ..
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/python/dparser.i dparser-gitpull-export/python/dparser.i
--- d/python/dparser.i	2012-12-02 18:56:11.573132300 -0600
+++ dparser-gitpull-export/python/dparser.i	2012-12-02 20:05:32.000000000 -0600
@@ -6,7 +6,7 @@
 %include "pydparser.h"
 
 typedef struct d_loc_t {
-  long int s;
+  void *s: /* converting to a string would be too expensive */
   char *pathname, *ws;
   int col, line;
 } d_loc_t;
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/python/dparser.py dparser-gitpull-export/python/dparser.py
--- d/python/dparser.py	2012-12-02 18:56:11.573132300 -0600
+++ dparser-gitpull-export/python/dparser.py	2012-12-02 20:05:32.000000000 -0600
@@ -2,116 +2,125 @@
 # contributions by Milosz Krajewski
 # contributions by John Plevyak
 
-import sys, types, os, hashlib, dparser_swigc, string 
+import sys
+import types
+import os
+import hashlib
+import dparser_swigc
+import string
 
 class user_pyobjectsPtr :
-    def __init__(self,this):
+    def __init__(self, this):
         self.this = this
-        self.thisown = 0
-    def __setattr__(self,name,value):
-        if name == "t" :
+
+    def __setattr__(self, name, value):
+        if name == "t":
             self.this.__setattr__(name, value)
             return
         self.__dict__[name] = value
+
     def __getattr__(self,name):
-        if name == "t" : 
+        if name == "t":
             return self.this.__getattr__(name)
-        raise AttributeError,name
+        raise AttributeError(name)
+
     def __repr__(self):
         return "<C user_pyobjects instance>"
-    
-class user_pyobjects(user_pyobjectsPtr):
-    def __init__(self,this):
-        self.this = this
 
-class d_loc_tPtr :
+class d_loc_tPtr:
     def __init__(self, this, d_parser):
         self.this = this
-        self.thisown = 0
         self.d_parser = d_parser
+
     def __setattr__(self, name, value):
         if name == "s" :
-            dparser_swigc.my_d_loc_t_s_set(self.this,self.d_parser,value)
+            dparser_swigc.my_d_loc_t_s_set(self.this, self.d_parser, value)
         elif name in ["pathname", "previous_col", "col", "line", "ws"]:
-            self.this.__setattr__(name, value)     
+            self.this.__setattr__(name, value)
         else:
             self.__dict__[name] = value
-        
+
     def __getattr__(self, name):
-        if name == "s" : 
-            return dparser_swigc.my_d_loc_t_s_get(self.this,self.d_parser)
+        if name == "s" :
+            return dparser_swigc.my_d_loc_t_s_get(self.this, self.d_parser)
         elif name in ["pathname", "previous_col", "col", "line", "ws"]:
             return self.this.__getattr__(name)
-        raise AttributeError,name
+        raise AttributeError(name)
 
     def __repr__(self):
         return "<C d_loc_t instance>"
-    
-    
+
+
 class d_loc_t(d_loc_tPtr):
     def __init__(self, this, d_parser, buf):
-        self.this = this
-        self.d_parser = d_parser
+        d_loc_tPtr.__init__(self, this, d_parser)
         self.buf = buf
-        
-class D_ParseNodePtr :
+
+class D_ParseNodePtr:
     def __init__(self, this):
         self.this = this
-        self.thisown = 0
+
     def __setattr__(self, name, value):
         if name == "end_skip" :
-            dparser_swigc.my_D_ParseNode_end_skip_set(self.this,self.d_parser,value)
+            dparser_swigc.my_D_ParseNode_end_skip_set(self.this, self.d_parser, value)
         elif name == "end" :
-            dparser_swigc.my_D_ParseNode_end_set(self.this,self.d_parser,value)
+            dparser_swigc.my_D_ParseNode_end_set(self.this, self.d_parser, value)
         elif name in ["start_loc", "globals", "user"]:
             self.this.__setattr__(name, value)
         else:
             self.__dict__[name] = value
-        
+
     def __getattr__(self, name):
-        if name == "symbol" : 
-            return dparser_swigc.my_D_ParseNode_symbol_get(self.this,self.d_parser).decode('string_escape')
-        elif name == "end" : 
-            return dparser_swigc.my_D_ParseNode_end_get(self.this,self.d_parser)
-        elif name == "end_skip" : 
-            return dparser_swigc.my_D_ParseNode_end_skip_get(self.this,self.d_parser)
-        elif name == "globals" : 
+        if name == "symbol" :
+            return dparser_swigc.my_D_ParseNode_symbol_get(self.this, self.d_parser).decode('string_escape')
+        elif name == "end" :
+            return dparser_swigc.my_D_ParseNode_end_get(self.this, self.d_parser)
+        elif name == "end_skip" :
+            return dparser_swigc.my_D_ParseNode_end_skip_get(self.this, self.d_parser)
+        elif name == "globals" :
             return self.this.__getattr__(name)
         elif name == "number_of_children":
             return dparser_swigc.d_get_number_of_children(self.this)
-        elif name == "user" : 
+        elif name == "user" :
             return user_pyobjectsPtr(self.this.__getattr__(name))
         elif name == "start_loc" :
             val = self.__dict__.get(name)
             if not val:
                 val = self.__dict__[name] = d_loc_t(self.this.start_loc, self.d_parser, self.buf)
             return val
-        if name == "c":
-            val = self.__dict__.get(name, None)
-            if not val:
+        elif name == "c":
+            children = self.__dict__.get(name, None)
+            if not children:
                 nc = dparser_swigc.d_get_number_of_children(self.this)
-                val = self.__dict__[name] = [None]*nc
-                for i in range(0, nc):
-                    val[i] = D_ParseNode(dparser_swigc.d_get_child(self.this, i), self.d_parser, self.buf)
-            return val
-        raise AttributeError,name
-        
+                children = []
+                for _ in xrange(dparser_swigc.d_get_number_off_children(self.this)):
+                    children.append(
+                        D_ParseNode(dparser_swigc.d_get_child(self.this, i),
+                                    self.d_parser, self.buf)
+                    )
+                self.__dict__[name] = children
+            return children
+        raise AttributeError(name)
+
     def __repr__(self):
         return "<C D_ParseNode instance>"
-    
+
 class D_ParseNode(D_ParseNodePtr):
-    def __del__(self):
-        dparser_swigc.remove_parse_tree_viewer(self.d_parser)
     def __init__(self, this, d_parser, buf):
-        self.this = this
+        D_ParseNodePtr.__init__(self, this)
         self.d_parser = d_parser
         self.buf = buf
         dparser_swigc.add_parse_tree_viewer(self.d_parser)
 
-class Reject: pass
+    def __del__(self):
+        dparser_swigc.remove_parse_tree_viewer(self.d_parser)
+
+class Reject:
+    pass
 
 class SyntaxError(Exception):
     pass
+
 class AmbiguityException(Exception):
     pass
 
@@ -130,69 +139,64 @@
     begin = loc.buf[mn:loc.s]
     end = loc.buf[loc.s:mx]
     string = '\n\nsyntax error, line:' + str(loc.line) + '\n\n' + be + begin +  '[syntax error]' + end + ee + '\n'
-    raise SyntaxError, string
+    raise SyntaxError(string)
 
 def my_ambiguity_func(nodes):
-    raise AmbiguityException, "\nunresolved ambiguity.  Symbols:\n" + string.join([node.symbol for node in nodes], "\n")
+    raise AmbiguityException("\nunresolved ambiguity.  Symbols:\n" + '\n'.join([node.symbol for node in nodes]))
 
 class Tables:
     def __init__(self):
-        self.sig = hashlib.md5();
-        self.sig.update('1.15')
+        self.sig = hashlib.md5('1.15')
         self.tables = None
-        
+
     def __del__(self):
-        del self.sig
         if self.tables:
             dparser_swigc.unload_parser_tables(self.tables)
-        
+
     def update(self,data):
         self.sig.update(data)
-        
+
     def sig_changed(self, filename):
-        try:
-            sig_file = open(filename + ".md5", "rb")
-            line = sig_file.read()
-            sig_file.close()
-            if line == self.sig.digest():
-                return 0
-        except IOError, SyntaxError:
-            pass
-        return 1
-        
-    def load_tables(self,grammar_str, filename, make_grammar_file):
+        filename = filename + '.md5'
+        if os.path.exists(filename):
+            with open(filename, 'rb') as fh:
+                return fh.read() != self.sig.digest()
+        return True
+
+    def load_tables(self, grammar_str, filename, make_grammar_file):
         if make_grammar_file:
-            g_file = open(filename, "wb") # 'binary' mode has been set to force \n on end of the line
-            g_file.write(grammar_str)
-            g_file.close()
-            
+            with open(filename, 'wb') as fh:
+                fh.write(grammar_str)
+
         if self.sig_changed(filename):
             dparser_swigc.make_tables(grammar_str, filename)
-            sig_file = open(filename + ".md5", "wb")
-            sig_file.write(self.sig.digest())
-            sig_file.close()
+            with open(filename + '.md5', 'wb') as fh:
+                fh.write(self.sig.digest())
 
         if self.tables:
             dparser_swigc.unload_parser_tables(self.tables)
         self.tables = dparser_swigc.load_parser_tables(filename + ".d_parser.dat")
-     
+
     def getTables(self):
         return self.tables
-        
+
 class ParsingException(Exception):
     pass
-    
+
+class NoActionsFound(Exception):
+    pass
+
 class Parser:
-    def __init__(self, modules=None, parser_folder=None, file_prefix="d_parser_mach_gen",make_grammar_file=0):
+    def __init__(self, modules=None, parser_folder=None,
+                 file_prefix="d_parser_mach_gen", make_grammar_file=False):
         self.tables = Tables()
         self.actions = []
         if not modules:
             try:
                 raise RuntimeError
             except RuntimeError:
-                e,b,t = sys.exc_info()
-            
-            dicts = [t.tb_frame.f_back.f_globals]
+                traceback = sys.exc_info()[2]
+                dicts = [traceback.tb_frame.f_back.f_globals]
         else:
             if isinstance(modules, list):
                 dicts = [module.__dict__ for module in modules]
@@ -200,30 +204,30 @@
                 dicts = [modules]
             else:
                 dicts = [modules.__dict__]
-                
+
         functions = []
         for dictionary in dicts:
-            f = [val for name, val in dictionary.items() 
+            f = [val for name, val in dictionary.items()
                  if (isinstance(val, types.FunctionType)) and name[0:2] == 'd_']
             f.sort(lambda x, y: cmp(x.func_code.co_filename, y.func_code.co_filename) or cmp(x.func_code.co_firstlineno, y.func_code.co_firstlineno))
             functions.extend(f)
         if len(functions) == 0:
             raise "\nno actions found.  Action names must start with 'd_'"
-            
+
         if parser_folder == None:
             parser_folder = os.path.dirname(sys.argv[0])
             if len(parser_folder) == 0:
                  parser_folder = os.getcwd()
             parser_folder = string.replace(parser_folder, '\\', '/')
-            
+
         self.filename = os.path.join(parser_folder, file_prefix + ".g")
-        
+
         grammar_str = []
         self.takes_strings = 0
         self.takes_globals = 0
         for f in functions:
             if f.__doc__:
-                grammar_str.append(f.__doc__) 
+                grammar_str.append(f.__doc__)
                 self.tables.update(f.__doc__)
             else:
                 raise "\naction missing doc string:\n\t" + f.__name__
@@ -256,59 +260,54 @@
                     raise "\nunknown argument name:\n\t" + var + "\nin function:\n\t" + f.__name__
             self.actions.append((f, arg_types, speculative))
         grammar_str = string.join(grammar_str, '')
-        
+
         self.tables.load_tables(grammar_str, self.filename, make_grammar_file)
 
     def parse(self, buf, buf_offset=0,
               initial_skip_space_fn=None,
               syntax_error_fn=my_syntax_error_func, ambiguity_fn=my_ambiguity_func,
               make_token=None,
-              dont_fixup_internal_productions=0,
-			  fixup_EBNF_productions=0,
-              dont_merge_epsilon_trees=0,
+              dont_fixup_internal_productions=False,
+              fixup_EBNF_productions=False,
+              dont_merge_epsilon_trees=False,
               commit_actions_interval=100,
-              error_recovery=0,
-              print_debug_info=0,
-              partial_parses=0,
-              dont_compare_stacks=0,
-              dont_use_greediness_for_disambiguation=0,
-              dont_use_height_for_disambiguation=0,
+              error_recovery=False,
+              print_debug_info=False,
+              partial_parses=False,
+              dont_compare_stacks=False,
+              dont_use_greediness_for_disambiguation=False,
+              dont_use_height_for_disambiguation=False,
               start_symbol=''):
-                  
+
         if not isinstance(buf, basestring):
             raise ParsingException("Message to parse is not a string: %r" % buf)
-                  
-        parser = dparser_swigc.make_parser(self.tables.getTables(), self, Reject, make_token, d_loc_t, D_ParseNode,
-                                           self.actions, initial_skip_space_fn, syntax_error_fn,
-                                           ambiguity_fn,
-                                           dont_fixup_internal_productions, fixup_EBNF_productions,
-                                           dont_merge_epsilon_trees,
-                                           commit_actions_interval,
-                                           error_recovery,
-                                           print_debug_info,
-                                           partial_parses,
-                                           dont_compare_stacks,
-                                           dont_use_greediness_for_disambiguation,
-                                           dont_use_height_for_disambiguation,
-                                           start_symbol, self.takes_strings, self.takes_globals)
+
+        parser = dparser_swigc.make_parser(
+            self.tables.getTables(), self, Reject, make_token, d_loc_t, D_ParseNode,
+            self.actions, initial_skip_space_fn, syntax_error_fn, ambiguity_fn,
+            dont_fixup_internal_productions, fixup_EBNF_productions,
+            dont_merge_epsilon_trees, commit_actions_interval, error_recovery,
+            print_debug_info, partial_parses, dont_compare_stacks,
+            dont_use_greediness_for_disambiguation, dont_use_height_for_disambiguation,
+            start_symbol, self.takes_strings, self.takes_globals
+        )
         result = dparser_swigc.run_parser(parser, buf, buf_offset)
         return ParsedStructure(result)
-        
+
 class ParsedStructure:
-    def __init__(self,result):
-        self.stringLeft = ""
+    def __init__(self, result):
+        self.string_left = ""
         self.structure = None
         self.top_node = None
         if result:
             if len(result) == 3:
-                self.stringLeft = result[2]
+                self.string_left = result[2]
             node = result[1]
             self.top_node = node #D_ParseNode(node.this, node.d_parser, node.buf)
             self.structure = result[0]
-        
+
     def getStructure(self):
         return self.structure
-    
+
     def getStringLeft(self):
-        return self.stringLeft
-		
+        return self.string_left
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/python/pydparser.c dparser-gitpull-export/python/pydparser.c
--- d/python/pydparser.c	2012-12-02 18:56:11.573132300 -0600
+++ dparser-gitpull-export/python/pydparser.c	2012-12-02 20:05:32.000000000 -0600
@@ -206,7 +206,12 @@
   }
   arglist = Py_BuildValue("(O)", list);
   result = PyEval_CallObject(d_interface(dp)->ambiguity_fn, arglist);
-  if(result == Py_None) {
+  if (result == NULL) {
+    PyErr_Print();
+    goto hack;
+  }
+  if (result == Py_None) {
+hack:
     Py_DECREF(list);
     Py_DECREF(arglist);
     i = 0;
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/python/setup.py dparser-gitpull-export/python/setup.py
--- d/python/setup.py	2012-12-02 18:56:11.573132300 -0600
+++ dparser-gitpull-export/python/setup.py	2012-12-02 20:05:32.000000000 -0600
@@ -18,7 +18,7 @@
     define_macros = [('SWIG_GLOBAL', None)],
                          libraries = ['mkdparse', 'dparse'],
                          library_dirs = ['../'],
-                         extra_compile_args = ['-Wall'])
+                         extra_compile_args = ['-Wall', '-ggdb3'])
     
 setup(name="dparser",
     cmdclass = {"install_data": smart_install_data},
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/python/tests/test6.py dparser-gitpull-export/python/tests/test6.py
--- d/python/tests/test6.py	2012-12-02 18:56:11.573132300 -0600
+++ dparser-gitpull-export/python/tests/test6.py	2012-12-02 20:05:32.000000000 -0600
@@ -5,12 +5,9 @@
 
 # turn a tree of strings into a single string (slowly):
 def stringify(s):
-    if type(s) == str:
-        return s
-    out = ''
-    for c in s:
-        out += stringify(c)
-    return out
+    if not isinstance(s, str):
+        return ''.join(map(stringify, s))
+    return s
 
 def d_add1(t, s):
     "add : add '%' exp"
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/sample.g dparser-gitpull-export/sample.g
--- d/sample.g	2012-12-02 18:56:11.573132300 -0600
+++ dparser-gitpull-export/sample.g	2012-12-02 20:05:32.000000000 -0600
@@ -6,6 +6,8 @@
 #include "d.h"
 }
 
+${declare longest_match program}
+
 program : statement*;
 
 statement : external | definition | expression ';' ;
@@ -16,7 +18,7 @@
   char *ts = dup_str($n0.start_loc.s, $n0.end);
   ${scope} = new_D_Scope(${scope});
   s = NEW_D_SYM(${scope}, $n0.start_loc.s, $n0.end); 
-  printf("def Sym '%s' line %d: %p\n", ts,  $n0.start_loc.line, s);
+  printf("def Sym '%s' line %d: %X\n", ts,  $n0.start_loc.line, (int)(uintptr_t)s);
   d_free(ts);
   $$ = s;
 };
@@ -35,9 +37,9 @@
 	  D_Sym *s = find_D_Sym(${scope}, $n0.start_loc.s, $n0.end);
           char *ts = dup_str($n0.start_loc.s, $n0.end);
 	  if (s)
-  	    printf("ref Sym '%s' line %d val %d: %p of %p\n",
+  	    printf("ref Sym '%s' line %d val %d: %X of %X\n",
 	           ts, $n0.start_loc.line,
-		   s->user, s, s->update_of);
+		   s->user, (int)(uintptr_t)s, (int)(uintptr_t)s->update_of);
 	  else
  	    printf("ref Sym '%s' line %d: not found\n",
                    ts, $n0.start_loc.line);
@@ -63,7 +65,9 @@
 strings : string+;
 
 binary_operator
-	: '.'		$binary_op_left 9900
+	: '::'		$binary_op_right 10000
+        | '.'		$binary_op_left 9900
+	| '->'		$binary_op_left 9900
 	| '*'		$binary_op_left 9600
 	| '/'		$binary_op_left 9600
 	| '%'		$binary_op_left 9600
@@ -94,31 +98,29 @@
 	| '|='		$binary_op_left 8500
 	| '^='		$binary_op_left 8500
 	| ','		$binary_op_left 8400
-	| '->'		$binary_op_left 9900
-	| '::'		$binary_op_right 10000
 	|		$binary_op_left 7000
 	;
 
 pre_operator
-	: '--'		$unary_op_right 9800
+	: '::'          $unary_op_right	10000
+	| '--'		$unary_op_right 9800
 	| '++'		$unary_op_right 9800
-	| '-'		$unary_op_right 9800
-	| '+'		$unary_op_right 9800
-	| '~'		$unary_op_right 9800
-	| '!'		$unary_op_right 9800
-	| '*'		$unary_op_right 9800
-	| '&'		$unary_op_right 9800
-	| '(' external_type ')' $unary_op_right 9800
-	| 'sizeof'	 $unary_op_right	9900
-	| '::'		 $unary_op_right	10000
+        | '-'		$unary_op_right 8600
+	| '+'		$unary_op_right 8600
+	| '~'		$unary_op_right 8600
+	| '!'		$unary_op_right 8600
+	| '*'		$unary_op_right 8600
+	| '&'		$unary_op_right 8600
+	| '(' external_type ')' $unary_op_right 8600
+	| 'sizeof'	 $unary_op_right	8600
 	;
 
 post_operator
-	: '--' 	$unary_op_left 9800
-	| '++' 	$unary_op_left 9800
-	| '{' expression '}' $unary_op_left 9900
-	| '(' expression ')' $unary_op_left 9900
-	| '[' expression ']' $unary_op_left 9900
+	: '--' 	$unary_op_left 9700
+	| '++' 	$unary_op_left 9700
+	| '{' expression '}' $unary_op_left 9700
+	| '(' expression ')' $unary_op_left 9700
+	| '[' expression ']' $unary_op_left 9700
 	;
 
 builtin_types
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/scan.c dparser-gitpull-export/scan.c
--- d/scan.c	2012-12-02 18:56:11.588732300 -0600
+++ dparser-gitpull-export/scan.c	2012-12-02 20:05:32.000000000 -0600
@@ -7,7 +7,7 @@
 int
 scan_buffer(d_loc_t *aloc, D_State *parse_state, ShiftResult *results) {
   d_loc_t loc = *aloc, last_loc = *aloc;
-  char *s = loc.s, *scol = 0;
+  char *s = loc.s;
   int col = loc.col, line = loc.line;
   int nresults = 0, i = 0, j;
   D_Shift **shift = NULL, **shift_diff = 0;
@@ -33,7 +33,7 @@
 	  }
 	}
 	prev = state;
-	if (c == '\n') { line++; col = 0; scol = s; } else col++;
+	if (c == '\n') { line++; col = 0; } else col++;
 	loc.s = s; loc.line = line; loc.col = col;
 	if (st[state].shift) {
 	  last = state;
@@ -69,7 +69,7 @@
 	  last = state;
 	  last_loc = loc;
 	}
-	if (c == '\n') { line++; col = 0; scol = s; } else col++;
+	if (c == '\n') { line++; col = 0; } else col++;
 	c = (uint8)*s++;
       }
       shift = st[last].shift;
@@ -100,7 +100,7 @@
 	  last = state;
 	  last_loc = loc;
 	}
-	if (c == '\n') { line++; col = 0; scol = s; } else col++;
+	if (c == '\n') { line++; col = 0; } else col++;
 	c = (uint8)*s++;
       }
       shift = st[last].shift;
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/symtab.c dparser-gitpull-export/symtab.c
--- d/symtab.c	2012-12-02 18:56:11.588732300 -0600
+++ dparser-gitpull-export/symtab.c	2012-12-02 20:05:32.000000000 -0600
@@ -18,8 +18,8 @@
   also has a tree of all 'updates' representing different
   views of the state of scoped variables by each speculative
   parse state.  Periodically, when the parse state collapses
-  to a single state (we are nolonger speculating), these changes
-  are can be 'committed' and the changes pushed into the top
+  to a single state (we are no longer speculating), these changes
+  can be 'committed' and the changes pushed into the top
   level hash table.
  
   All D_Scope's except the top level just have a 'll' of symbols, the
@@ -35,8 +35,8 @@
   the next D_Scope to look in for 'updates' after the current one has been
   searched.
 
-  'down' and 'down_next' are used to hold enclosing scopes, or in the
-  case of the top level, sibling scopes (created by commmit).
+  'down' and 'down_next' are used to hold enclosed scopes, or in the
+  case of the top level, sibling scopes (created by commit).
 */
   
 
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/1.g dparser-gitpull-export/tests/1.g
--- d/tests/1.g	2012-12-02 18:56:11.588732300 -0600
+++ dparser-gitpull-export/tests/1.g	1969-12-31 18:00:00.000000000 -0600
@@ -1,4 +0,0 @@
-S: C*
-C: A B? { printf("%d"
-A: 'a'
-B: 'b'
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/g22.test.g.1.check dparser-gitpull-export/tests/g22.test.g.1.check
--- d/tests/g22.test.g.1.check	2012-12-02 18:56:11.619932400 -0600
+++ dparser-gitpull-export/tests/g22.test.g.1.check	2012-12-02 20:05:32.000000000 -0600
@@ -1,2 +1,2 @@
 14 states 7 scans 5 shifts 8 reductions 1 compares 0 ambiguities
-( x  +  x )
+( x ( +  x ))
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/g23.test.g.1.check dparser-gitpull-export/tests/g23.test.g.1.check
--- d/tests/g23.test.g.1.check	2012-12-02 18:56:11.619932400 -0600
+++ dparser-gitpull-export/tests/g23.test.g.1.check	2012-12-02 20:05:32.000000000 -0600
@@ -1,2 +1,2 @@
 10 states 8 scans 5 shifts 5 reductions 1 compares 0 ambiguities
-( x  +  x )
+( x ( +  x ))
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/g40.test.g.1.check dparser-gitpull-export/tests/g40.test.g.1.check
--- d/tests/g40.test.g.1.check	2012-12-02 18:56:11.651132400 -0600
+++ dparser-gitpull-export/tests/g40.test.g.1.check	2012-12-02 20:05:32.000000000 -0600
@@ -1,2 +1,2 @@
-59 states 41 scans 21 shifts 36 reductions 2 compares 0 ambiguities
-((( a  b  : )( b  +  b )) ; )
+59 states 41 scans 21 shifts 38 reductions 2 compares 0 ambiguities
+((( a  b  : )( b ( +  b ))) ; )
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/g50.test.g.1.check dparser-gitpull-export/tests/g50.test.g.1.check
--- d/tests/g50.test.g.1.check	2012-12-02 18:56:11.666732500 -0600
+++ dparser-gitpull-export/tests/g50.test.g.1.check	2012-12-02 20:05:32.000000000 -0600
@@ -14,7 +14,7 @@
 :159: syntax error after '}}
 	'
 :160: syntax error after ')'
-:161: syntax error after 'RightButton) ) {
+:161: syntax error after 'LeftButton || button == Key.RightButton) ) {
 			if(!dragged) '
 :162: syntax error after '}'
 :163: syntax error after '}'
@@ -33,6 +33,9 @@
 			if( modifiers[Key.LeftShift] '
 :169: syntax error after ')'
 :171: syntax error after '}'
-:176: syntax error after ';'
-:177: syntax error after ';'
-fatal error, '' line 177
+:185: syntax error after 't'
+:187: syntax error after ';'
+:188: syntax error after ';'
+:189: syntax error after ';'
+:190: syntax error after ';'
+fatal error, '' line 190
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/g51.test.g dparser-gitpull-export/tests/g51.test.g
--- d/tests/g51.test.g	1969-12-31 18:00:00.000000000 -0600
+++ dparser-gitpull-export/tests/g51.test.g	2012-12-02 20:05:32.000000000 -0600
@@ -0,0 +1,5 @@
+expr: 'x'
+    | '-' expr $unary_right 3
+    | '!' expr $unary_right 1
+    | expr '+' expr $binary_right 2
+    ;
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/g51.test.g.1 dparser-gitpull-export/tests/g51.test.g.1
--- d/tests/g51.test.g.1	1969-12-31 18:00:00.000000000 -0600
+++ dparser-gitpull-export/tests/g51.test.g.1	2012-12-02 20:05:32.000000000 -0600
@@ -0,0 +1 @@
+-!x
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/g51.test.g.1.check dparser-gitpull-export/tests/g51.test.g.1.check
--- d/tests/g51.test.g.1.check	1969-12-31 18:00:00.000000000 -0600
+++ dparser-gitpull-export/tests/g51.test.g.1.check	2012-12-02 20:05:32.000000000 -0600
@@ -0,0 +1,2 @@
+7 states 6 scans 3 shifts 3 reductions 0 compares 0 ambiguities
+( - ( !  x ))
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/sample.test.g dparser-gitpull-export/tests/sample.test.g
--- d/tests/sample.test.g	2012-12-02 18:56:11.682332500 -0600
+++ dparser-gitpull-export/tests/sample.test.g	2012-12-02 20:05:32.000000000 -0600
@@ -65,7 +65,9 @@
 strings : string+;
 
 binary_operator
-	: '.'		$binary_op_left 9900
+	: '::'		$binary_op_right 10000
+        | '.'		$binary_op_left 9900
+	| '->'		$binary_op_left 9900
 	| '*'		$binary_op_left 9600
 	| '/'		$binary_op_left 9600
 	| '%'		$binary_op_left 9600
@@ -96,31 +98,29 @@
 	| '|='		$binary_op_left 8500
 	| '^='		$binary_op_left 8500
 	| ','		$binary_op_left 8400
-	| '->'		$binary_op_left 9900
-	| '::'		$binary_op_right 10000
 	|		$binary_op_left 7000
 	;
 
 pre_operator
-	: '-'		$unary_op_right 9800
-	| '+'		$unary_op_right 9800
-	| '~'		$unary_op_right 9800
-	| '!'		$unary_op_right 9800
-	| '*'		$unary_op_right 9800
-	| '&'		$unary_op_right 9800
+	: '::'          $unary_op_right	10000
 	| '--'		$unary_op_right 9800
 	| '++'		$unary_op_right 9800
-	| '(' external_type ')' $unary_op_right 9800
-	| 'sizeof'	 $unary_op_right	9900
-	| '::'		 $unary_op_right	10000
+        | '-'		$unary_op_right 8600
+	| '+'		$unary_op_right 8600
+	| '~'		$unary_op_right 8600
+	| '!'		$unary_op_right 8600
+	| '*'		$unary_op_right 8600
+	| '&'		$unary_op_right 8600
+	| '(' external_type ')' $unary_op_right 8600
+	| 'sizeof'	 $unary_op_right	8600
 	;
 
 post_operator
-	: '--' 	$unary_op_left 9800
-	| '++' 	$unary_op_left 9800
-	| '{' expression '}' $unary_op_left 9900
-	| '(' expression ')' $unary_op_left 9900
-	| '[' expression ']' $unary_op_left 9900
+	: '--' 	$unary_op_left 9700
+	| '++' 	$unary_op_left 9700
+	| '{' expression '}' $unary_op_left 9700
+	| '(' expression ')' $unary_op_left 9700
+	| '[' expression ']' $unary_op_left 9700
 	;
 
 builtin_types
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/tests/utf8.test.g.out dparser-gitpull-export/tests/utf8.test.g.out
--- d/tests/utf8.test.g.out	1969-12-31 18:00:00.000000000 -0600
+++ dparser-gitpull-export/tests/utf8.test.g.out	2012-12-02 20:05:32.000000000 -0600
@@ -0,0 +1,5 @@
+239 states 104 scans 23 shifts 133 reductions 0 compares 0 ambiguities
+4 productions 3 terminals 8 states 0 declarations
+1 scanners 1 transitions
+13 states 4 scans 3 shifts 9 reductions 0 compares 0 ambiguities
+( a  φ  ω )
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/TODO dparser-gitpull-export/TODO
--- d/TODO	1969-12-31 18:00:00.000000000 -0600
+++ dparser-gitpull-export/TODO	2012-12-02 20:05:32.000000000 -0600
@@ -0,0 +1,18 @@
+- fix issues with terminal priority when the different parses are
+coming from different states.... what does this mean?
+- fix ambiguity handling for parsing from start states... need to force a final reduction
+  either bloat the state table (probably best), or try to force the reduction manually....
+- memory leaks on error recovery
+- add trailing context to regular expressions
+- enhance cmp_stacks
+- optimize speed
+? LALR
+? error repair a la Carl Cerecke
+? split global state on demand
+? ensure that states only summarize identical .scope, .globals and .skip_space
+? eager parser
+
+handle path for include files
+add option to name the output file.
+
+fix issue with equiv_D_Scope.
diff -Naur '--exclude=.git' '--exclude=*.o' '--exclude=*.a' '--exclude=.project' '--exclude=.cproject' '--exclude=*.exe' d/write_tables.c dparser-gitpull-export/write_tables.c
--- d/write_tables.c	2012-12-02 18:56:11.729132600 -0600
+++ dparser-gitpull-export/write_tables.c	2012-12-02 20:05:32.000000000 -0600
@@ -903,7 +903,7 @@
   Vec(intptr_t) vgoto;
   State *s;
   uint8 *goto_valid = NULL;
-  int i, j, x, again, lowest, nvalid_bytes, sym, lowest_sym;
+  int i, j, x, again, nvalid_bytes, sym, lowest_sym;
 
   nvalid_bytes = ((g->productions.n + g->terminals.n) + 7) / 8;
   goto_valid = MALLOC(nvalid_bytes);
@@ -918,16 +918,13 @@
 	  s->goto_on_token = 1;
       /* find lowest goto, set valid bits */
       memset(goto_valid, 0, nvalid_bytes);
-      lowest = 0;
       lowest_sym = elem_symbol(g, s->gotos.v[0]->elem);
       SET_BIT(goto_valid, lowest_sym);
       for (j = 1; j < s->gotos.n; j++) {
 	sym = elem_symbol(g, s->gotos.v[j]->elem);
 	SET_BIT(goto_valid, sym);
-	if (sym < lowest_sym) {
-	  lowest = j;
+	if (sym < lowest_sym)
 	  lowest_sym = sym;
-	}
       }
       /* insert into vgoto */
       again = 1;
@@ -1118,6 +1115,26 @@
         if (in_string == c[1]) in_string = 0; else if (!in_string) in_string = c[1];
       }
     }
+    if (!in_string && *c == '/') {
+      // pass through c++ style comments
+      if (c[1] == '/') {
+        while (*c && *c != '\n') {
+          fputc(*c, fp); 
+          c++;
+        }
+      } else if (c[1] == '*') {
+        while (*c && *c != '*' && c[1] != '\\') {
+          fputc(*c, fp); 
+          c++;
+        }
+        if (*c) {
+          fputc(*c, fp); 
+          c++;
+          fputc(*c, fp); 
+          c++;
+        }
+      }
+    }
     if (*c == '\n')
       g->write_line++;
     if (!in_string && *c == '$') {
